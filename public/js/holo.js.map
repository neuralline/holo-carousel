{"version":3,"file":"holo.js","sources":["../../node_modules/.pnpm/cyre@3.1.4/node_modules/cyre/dist/umd/cyre.js","../../src/config/holo-config.ts","../../src/libs/holo-dom.ts","../../src/components/orientation-handler.ts","../../src/libs/holo-navigation.ts","../../src/core/holo-events.ts","../../src/libs/holo-essentials.ts","../../src/components/holo-touch.ts","../../src/components/holo-io-manager.ts","../../src/core/holo-state.ts","../../src/components/holo-create-element.ts","../../src/core/holo-performance.ts","../../src/libs/debug.ts","../../src/app.ts","../../src/components/holo-initiate.ts"],"sourcesContent":["!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((e=\"undefined\"!=typeof globalThis?globalThis:e||self).cyre=e.cyre||{})}(this,(function(e){\"use strict\";const t={reset:\"\u001b[0m\",magenta:\"\u001b[35m\",magentaBright:\"\u001b[95m\",red:\"\u001b[31m\",redBright:\"\u001b[91m\",green:\"\u001b[32m\",greenBright:\"\u001b[92m\",cyan:\"\u001b[36m\",cyanBright:\"\u001b[96m\",yellow:\"\u001b[33m\",yellowBright:\"\u001b[93m\",white:\"\u001b[37m\",whiteBright:\"\u001b[97m\",blue:\"\u001b[34m\",blueBright:\"\u001b[94m\",bgRed:\"\u001b[41m\",bgYellow:\"\u001b[43m\",bgBlue:\"\u001b[44m\",bold:\"\u001b[1m\",dim:\"\u001b[2m\",italic:\"\u001b[3m\",underline:\"\u001b[4m\"},r={DEBUG:[\"dim\",\"cyan\"],INFO:[\"blue\",\"bold\"],WARN:[\"yellowBright\",\"bold\"],ERROR:[\"redBright\",\"bold\"],SUCCESS:[\"greenBright\",\"bold\"]},o=\"undefined\"!=typeof process&&process.versions&&process.versions.node,i=\"undefined\"!=typeof window;const a={DEBUG:0,INFO:1,WARN:2,ERROR:3,SUCCESS:1},n=(e,r,n)=>(s,c=!0,u=!1)=>{if(a[e]<a.DEBUG)return;const l=((e,t,r)=>`${r?`[${(new Date).toISOString()}]`:\"\"} ${e}: ${t instanceof Error?`${t.message}\\n${t.stack}`:\"object\"==typeof t?JSON.stringify(t,null,2):String(t)}`)(e,s,c);if(u||i){const t=\"ERROR\"===e?\"color: red; font-weight: bold\":\"WARN\"===e?\"color: orange; font-weight: bold\":\"SUCCESS\"===e?\"color: green; font-weight: bold\":\"INFO\"===e?\"color: blue\":\"color: gray\";console[n](`%c${l}`,t)}else if(o){const e=r.reduce(((e,r)=>`${t[r]}${e}`),l);process.stdout.write(`${e}${t.reset}\\n`)}},s={error:n(\"ERROR\",r.ERROR,\"error\"),warn:n(\"WARN\",r.WARN,\"warn\"),info:n(\"INFO\",r.INFO,\"log\"),debug:n(\"DEBUG\",r.DEBUG,\"debug\"),success:n(\"SUCCESS\",r.SUCCESS,\"log\")},c=e=>{const t=new WeakMap;return(...r)=>{const o=r[0];return\"object\"==typeof o&&null!==o?(t.has(o)||t.set(o,e(...r)),t.get(o)):e(...r)}},u=(e,...t)=>t.reduce(((e,t)=>t(e)),e),l=(e,t)=>{if(Object.is(e,t))return!0;if(\"object\"!=typeof e||\"object\"!=typeof t||null===e||null===t)return!1;if(Array.isArray(e)&&Array.isArray(t))return e.length===t.length&&e.every(((e,r)=>l(e,t[r])));const r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((r=>l(e[r],t[r])))},d={RECUPERATION:6e4,MAX_TIMEOUT:Math.pow(2,31)-1},m=\"@cyre: System is offline\",p=\"@cyre: System is online\",g=\"@cyre: Welcome! How can I assist you?\",f=\"Failed to prepare action: invalid configuration\",y=\"Failed to execute action: runtime error\",h=\"Action skipped: no payload changes detected\",b=\"Failed to create channel: configuration error\",v=\"Channel created successfully\",E=\"Invalid channel data definition\",k=\"Channel ID is required\",I=\"Channel type is required\",T=\"Invalid channel type specified\",w=\"Invalid channel structure: check configuration\",R=\"Invalid subscription parameters provided\",A=\"Subscriber exists - updating configuration\",M=\"Successfully subscribed to event\",$=\"Invalid event handler provided\",C=\"Subscription failed: check configuration\",x=\"Call failed: system is offline\",O=\"Call failed: invalid action ID\",S=\"Call failed: action not responding\",D=\"Dispatch failed: no subscriber found for this type\",N=\"Q0.0U0.0A0.0N0.0T0.0U0.0M0 - I0.0N0.0C0.0E0.0P0.0T0.0I0.0O0.0N0.0S0-- \",q={MIN:50,BASE:200,MAX:1e3,RECOVERY:2e3},U={HIGH:.9,CRITICAL:.95},B={MAX_CPU:80,MAX_MEMORY:85,MAX_EVENT_LOOP:50,MAX_CALL_RATE:1e3},_={system:{cpu:0,memory:0,eventLoop:0,isOverloaded:!1},breathing:{breathCount:0,currentRate:q.BASE,lastBreath:Date.now(),stress:0,isRecuperating:!1,recuperationDepth:0,pattern:\"NORMAL\",nextBreathDue:Date.now()+q.BASE},performance:{callsTotal:0,callsPerSecond:0,lastCallTimestamp:Date.now(),activeQueues:{critical:0,high:0,medium:0,low:0,background:0},queueDepth:0},stress:{cpu:0,memory:0,eventLoop:0,callRate:0,combined:0},lastUpdate:Date.now(),inRecuperation:!1,hibernating:!1,activeFormations:0},F=()=>{const e=new Map;return{get:t=>e.get(t),set:(t,r)=>{e.set(t,r),e.size>1e3&&Array.from(e.keys()).slice(0,e.size-1e3).forEach((t=>e.delete(t)))},forget:t=>e.delete(t),clear:()=>e.clear(),getAll:()=>Array.from(e.values()),size:()=>e.size}},L=F();L.set(\"quantum\",_);const P=c(((e,t)=>{const r=Math.min(1,(e.cpu||0)/(.7*B.MAX_CPU)),o=Math.min(1,(e.memory||0)/(.7*B.MAX_MEMORY)),i=Math.min(1,(e.eventLoop||0)/(.7*B.MAX_EVENT_LOOP)),a=Math.min(1,(t.callsPerSecond||0)/(.7*B.MAX_CALL_RATE)),n=Math.max(r,o,i,a);return{cpu:r,memory:o,eventLoop:i,callRate:a,combined:Math.min(1,(r+o+i+a+2*n)/6)}})),X=e=>{if(e>=U.CRITICAL)return q.RECOVERY;const t=Math.exp(e)-1;return Math.max(q.MIN,Math.min(q.MAX,q.BASE*(1+t)))},j={inRecuperation:!1,hibernating:!1,activeFormations:0,recuperationInterval:void 0,get:()=>{const e=L.get(\"quantum\");return Object.freeze({...e,inRecuperation:j.inRecuperation,hibernating:j.hibernating,activeFormations:j.activeFormations})},update:e=>{const t={...L.get(\"quantum\"),...e,lastUpdate:Date.now(),inRecuperation:e.inRecuperation??j.inRecuperation,hibernating:e.hibernating??j.hibernating,activeFormations:e.activeFormations??j.activeFormations};return(e.system||e.performance)&&(t.stress=P(t.system,t.performance)),L.set(\"quantum\",t),t},updateBreath:e=>{const t=L.get(\"quantum\"),r=P(e,t.performance),o=Date.now(),i={...t.breathing,breathCount:t.breathing.breathCount+1,lastBreath:o,stress:r.combined,currentRate:X(r.combined),nextBreathDue:o+X(r.combined),isRecuperating:r.combined>U.HIGH,recuperationDepth:Math.min(1,r.combined),pattern:r.combined>U.HIGH?\"RECOVERY\":\"NORMAL\"};return j.update({system:e,breathing:i,stress:r,inRecuperation:i.isRecuperating})},recordCall:(e=\"medium\")=>{const t=L.get(\"quantum\"),r=Date.now(),o=r-t.performance.lastCallTimestamp>=1e3?1:t.performance.callsPerSecond+1,i={...t.performance,callsTotal:t.performance.callsTotal+1,callsPerSecond:o,lastCallTimestamp:r,activeQueues:{...t.performance.activeQueues,[e]:t.performance.activeQueues[e]+1},queueDepth:t.performance.queueDepth+1};return j.update({performance:i})},isHealthy:()=>{const e=L.get(\"quantum\");return!e.breathing.isRecuperating&&e.stress.combined<U.HIGH},shouldAllowCall:e=>{const t=L.get(\"quantum\");return t.breathing.isRecuperating?\"critical\"===e:t.stress.combined<U.HIGH||\"critical\"===e||\"high\"===e},reset:()=>{j.inRecuperation=!1,j.hibernating=!1,j.activeFormations=0,j.recuperationInterval&&(clearTimeout(j.recuperationInterval),j.recuperationInterval=void 0),L.set(\"quantum\",_)},forget:e=>{L.forget(e)}},H=F(),V=F(),G=F(),z=F(),W=F(),Y=e=>{const t=W.get(e);t?.intervalId&&clearInterval(t.intervalId),W.forget(e),z.forget(e)},Q=e=>{if(!e?.id)throw new Error(\"IO must have an id\");try{const t={...e,timestamp:Date.now(),type:e.type||e.id};Y(e.id),H.set(e.id,t),W.set(e.id,{lastExecutionTime:Date.now(),executionCount:0,errors:[]}),e.detectChanges&&z.set(e.id,e.payload),j.recordCall(e.priority?.level)}catch(t){throw s.error(`Failed to set IO: ${t instanceof Error?t.message:String(t)}`),t}},J=e=>H.get(e),K=e=>(Y(e),H.forget(e)),Z=()=>{H.getAll().forEach((e=>{e.id&&Y(e.id)})),z.clear(),W.clear(),H.clear(),j.reset()},ee=(e,t)=>{const r=z.get(e);return!l(t,r)},te=e=>z.get(e),re=e=>W.get(e),oe=e=>{if(!e?.id||!e?.fn)throw new Error(\"Invalid subscriber format\");V.set(e.id,e)},ie=e=>V.get(e),ae=()=>V.clear(),ne=e=>{e.id&&G.set(e.id,e)},se=e=>G.get(e),ce=e=>{const t=G.get(e);return t?.timeoutId&&clearTimeout(t.timeoutId),G.forget(e)},ue=()=>{G.getAll().forEach((e=>{e.timeoutId&&clearTimeout(e.timeoutId)})),G.clear()},le=()=>G.getAll(),de=()=>G.getAll().filter((e=>\"active\"===e.status)),me=e=>e.type&&e.id?{...e,ok:!0,status:\"active\"}:{...e,ok:!1,done:!1,status:\"error\",error:\"Missing required fields: type or id\"},pe=e=>{if(!e.detectChanges)return e;return ee(e.id,e.payload)?e:{...e,ok:!0,done:!0,status:\"skipped\",skipped:!0,skipReason:h}},ge=e=>{if(e.skipped||\"error\"===e.status)return e;try{const t=ie(e.id);if(!t)throw new Error(\"No subscriber found\");const r=t.fn(e.payload);return r&&\"object\"==typeof r&&\"id\"in r?{...e,ok:!0,done:!0,status:\"completed\",intraLink:{id:r.id,payload:r.payload}}:{...e,ok:!0,done:!0,status:\"completed\"}}catch(t){return s.error(`${y}: ${t}`),{...e,ok:!1,done:!1,status:\"error\",error:t instanceof Error?t.message:String(t)}}},fe=(e,t)=>{if(!e)return s.error(f),{id:\"\",type:\"\",ok:!1,done:!1,status:\"error\",error:f};try{return u((e=>{try{if(!e)throw new Error(f);return{...e,ok:!0,done:!1,status:\"pending\",timestamp:Date.now()}}catch(t){return{id:\"\",type:\"\",ok:!1,done:!1,status:\"error\",error:f}}})(e),me,pe,ge,(e=>\"error\"===e.status?e:(e=>(e.log&&(\"error\"===e.status?s.error(e):(e.status,s.info(e))),e))(e)),(e=>\"error\"===e.status?e:(e=>(e.ok&&!e.skipped&&Q({...e,timestamp:Date.now()}),e))(e)))}catch(r){return s.error(`Action processing failed: ${r}`),{...e,ok:!1,done:!1,status:\"error\",error:r instanceof Error?r.message:String(r)}}},ye=c((e=>e?e.id?e.type||e.id?e.type&&\"string\"!=typeof e.type?{isValid:!1,error:T}:{isValid:!0}:{isValid:!1,error:I}:{isValid:!1,error:k}:{isValid:!1,error:w})),he=(e,t)=>{try{if(!(\"object\"==typeof(r=e)&&null!==r&&\"id\"in r&&\"string\"==typeof r.id&&r.id.length>0))return s.error(w),{ok:!1,message:w};const o=ye(e);if(!o.isValid)return s.error(o.error),{ok:!1,message:o.error};if(!((e,t)=>!t||Object.entries(t).filter((([e,t])=>t(void 0).required)).map((([e])=>e)).every((t=>t in e)))(e,t))return s.error(E),{ok:!1,message:E};const i=((e,t)=>{try{const r={...e},o=[];for(const[i,a]of Object.entries(e)){const e=t[i];if(!e){r[i]=a;continue}const n=e(a);if(!n.ok){if(n.required)return{ok:!1,message:`Required field '${i}' validation failed: ${n.message}`,payload:r};o.push(`${i}: ${n.message}`)}r[i]=n.payload}for(const[i,a]of Object.entries(t))if(a(void 0).required&&!(i in e))return{ok:!1,message:`Missing required field: ${i}`,payload:r};return o.length>0?{ok:!1,message:o.join(\"; \"),payload:r}:{ok:!0,payload:r}}catch(r){const e=r instanceof Error?r.message:String(r);return s.error(`Data definition processing failed: ${e}`),{ok:!1,message:E}}})(e,t);if(!i.ok)return i;const a=(e=>{const t=Date.now();return{...e,type:e.type||e.id,timestamp:t,interval:e.interval||0,timeOfCreation:e.timeOfCreation||t}})({...i.payload,id:e.id});return s.success(v),{ok:!0,message:v,payload:a}}catch(o){const e=o instanceof Error?o.message:String(o);return s.error(`Channel processing failed: ${e}`),{ok:!1,message:b}}var r},be=(e,t)=>{try{const r=((e,t)=>e&&\"string\"==typeof e?\"function\"!=typeof t?{ok:!1,message:$,error:{code:\"INVALID_HANDLER\",message:\"Event handler must be a function\"}}:{ok:!0,message:M,subscriber:{id:e.trim(),fn:t}}:{ok:!1,message:T,error:{code:\"INVALID_TYPE\",message:`Type must be a non-empty string, received: ${e}`}})(e,t);if(!r.ok||!r.subscriber)return s.error(r.error||r.message),{ok:!1,message:r.message};const{subscriber:o}=r;return ie(o.id)&&s.info(`${o.id}: ${A}`),oe(o),s.info(`${M}: ${o.id}`),{ok:!0,message:`${M}: ${o.id}`}}catch(r){const e=r instanceof Error?r.message:String(r);return s.error(`Failed to add subscriber: ${e}`),{ok:!1,message:C}}},ve=(e,t)=>Array.isArray(e)?(e=>{try{const t=e.map((e=>{if(!e.id||!e.fn)return s.error(`Invalid subscriber format: ${JSON.stringify(e)}`),!1;try{return oe(e),!0}catch(t){return s.error(`Failed to add subscriber ${e.id}: ${t}`),!1}})).filter(Boolean).length,r=e.length;return 0===t?{ok:!1,message:`Failed to add any subscribers out of ${r}`}:{ok:!0,message:`Successfully added ${t} out of ${r} subscribers`}}catch(t){const e=t instanceof Error?t.message:String(t);return s.error(`Batch subscription failed: ${e}`),{ok:!1,message:C}}})(e):\"string\"==typeof e&&t?be(e,t):(s.error(R),{ok:!1,message:R}),Ee=async e=>{if(!e||!e.id)return;const t=performance.now(),r=se(e.id);if(r&&r.isActive)try{await e.callback();const o=performance.now()-t;r.metrics.totalExecutions++,r.metrics.successfulExecutions++,r.metrics.lastExecutionTime=o,r.metrics.longestExecutionTime=Math.max(r.metrics.longestExecutionTime,o),r.metrics.shortestExecutionTime=Math.min(r.metrics.shortestExecutionTime,o),r.metrics.averageExecutionTime=(r.metrics.averageExecutionTime*(r.metrics.totalExecutions-1)+o)/r.metrics.totalExecutions,r.executionCount++,r.lastExecutionTime=Date.now(),!0!==r.repeat&&\"number\"==typeof r.repeat&&(r.repeat=r.repeat-1),ne(r),!0===r.repeat||\"number\"==typeof r.repeat&&r.repeat>0?Ie(r):ce(r.id)}catch(o){const t=se(e.id);t&&(t.metrics.failedExecutions++,ne(t)),s.error(`Timer execution failed: ${o}`)}},ke=e=>{if(!e||!e.id)return;const t=e.duration>d.RECUPERATION?d.RECUPERATION:Math.max(e.duration/10,1e3);let r,o=Date.now();const i=()=>{const a=se(e.id);if(!a||!a.isActive)return void clearTimeout(r);const n=Date.now(),s=j.get(),c=1+(s.stress?.combined||0);if(n-o>t||Math.abs(c-1)>.1){const e=a.originalDuration-a.executionCount*d.MAX_TIMEOUT;a.duration=Math.min(e,d.MAX_TIMEOUT)*c,a.nextExecutionTime=n+a.duration,ne(a),o=n}s.hibernating||\"active\"!==a.status||(r=setTimeout(i,t),a.recuperationInterval=r,ne(a))};return r=setTimeout(i,t),r},Ie=e=>{if(!e||!e.id)return;const t=j.get();if(t.hibernating)return;const r=Date.now(),o=1+(t.stress?.combined||0),i=se(e.id);if(!i||!i.isActive)return;if(i.executionCount>1e4)return s.error(\"Maximum execution count exceeded\"),void ce(i.id);let a=i.duration*o;if(i.isInRecuperation){const e=i.originalDuration-i.executionCount*d.MAX_TIMEOUT;a=Math.min(e*o,d.MAX_TIMEOUT),i.duration=a,i.duration>d.RECUPERATION&&(i.recuperationInterval&&clearTimeout(i.recuperationInterval),i.recuperationInterval=ke(i)),e<=d.MAX_TIMEOUT&&(i.isInRecuperation=!1)}else i.duration=a;i.nextExecutionTime=r+i.duration,i.timeoutId&&clearTimeout(i.timeoutId);const n=\"undefined\"!=typeof process&&\"test\"===process.env.NODE_ENV;i.timeoutId=n?setTimeout((()=>Ee(i)),i.duration):i.duration<25?((e,t)=>{if(\"undefined\"!=typeof process&&\"test\"===process.env.NODE_ENV)return setTimeout(e,t);const r=process.hrtime(),o=()=>{const[i,a]=process.hrtime(r),n=1e3*i+a/1e6;if(n>=t)e();else{const e=t-n;e<1?setImmediate(o):e<25?setTimeout(o,0):setTimeout(o,Math.floor(e/2))}};return setTimeout(o,0)})((()=>Ee(i)),i.duration):setTimeout((()=>Ee(i)),i.duration),ne(i)},Te=(e,t,r,o=crypto.randomUUID())=>{try{const i=\"number\"==typeof e?e:(e=>24*(e.days||0)*60*60*1e3+60*(e.hours||0)*60*1e3+60*(e.minutes||0)*1e3+1e3*(e.seconds||0)+(e.milliseconds||0))(e),a=((e,t,r,o)=>{if(!e||\"number\"!=typeof t||\"function\"!=typeof r)throw new Error(\"Invalid formation parameters\");const i=Date.now(),a=t>=d.MAX_TIMEOUT,n=j.get(),s=1+(n.stress?.combined||0),c={id:e,startTime:i,duration:a?d.MAX_TIMEOUT:t*s,originalDuration:t,callback:r,repeat:o,executionCount:0,lastExecutionTime:0,nextExecutionTime:i+(a?d.MAX_TIMEOUT:t*s),isInRecuperation:a,status:\"active\",isActive:!0,metrics:{totalExecutions:0,successfulExecutions:0,failedExecutions:0,averageExecutionTime:0,lastExecutionTime:0,longestExecutionTime:0,shortestExecutionTime:1/0,missedExecutions:0}};return a&&(c.recuperationInterval=ke(c)),c})(o,i,t,r);return ne(a),Ie(a),{kind:\"ok\",value:a}}catch(i){return{kind:\"error\",error:i instanceof Error?i:new Error(\"Timer creation failed\")}}},we=e=>{if(e){const t=se(e);t&&(t.timeoutId&&clearTimeout(t.timeoutId),t.recuperationInterval&&clearTimeout(t.recuperationInterval),t.status=\"paused\",t.isActive=!1,ne(t))}else le().forEach((e=>{e.timeoutId&&clearTimeout(e.timeoutId),e.recuperationInterval&&clearTimeout(e.recuperationInterval),e.status=\"paused\",e.isActive=!1,ne(e)}))},Re=e=>{if(!j.get().hibernating)if(e){const t=se(e);t&&\"paused\"===t.status&&(t.status=\"active\",t.isActive=!0,ne(t),Ie(t))}else le().forEach((e=>{\"paused\"===e.status&&(e.status=\"active\",e.isActive=!0,ne(e),Ie(e))}))},Ae=()=>{j.update({hibernating:!0}),le().forEach((e=>{e.timeoutId&&clearTimeout(e.timeoutId),e.recuperationInterval&&clearTimeout(e.recuperationInterval)})),ue()},Me={id:(e=\"\")=>\"string\"==typeof e?{ok:!0,payload:e}:{ok:!1,payload:null,message:`action.id must be a string. Received '${e}'`,required:!0},type:(e=\"\")=>\"string\"==typeof e?{ok:!0,payload:e}:{ok:!1,payload:null,message:`action.type must be a string. Received '${e}'`,required:!0},payload:(e=null)=>({ok:!0,payload:e}),interval:(e=0)=>Number.isInteger(e)?{ok:!0,payload:e}:{ok:!1,payload:0,message:`'${e}' invalid action.interval value`,required:!1},timeOfCreation:(e=0)=>Number.isInteger(e)?{ok:!0,payload:e}:{ok:!1,payload:0,message:`'${e}' invalid @cyre.call time of creation value`,required:!0},repeat:(e=0)=>Number.isInteger(e)?{ok:!0,payload:e}:{ok:!1,payload:0,message:`'${e}' invalid action.repeat value`,required:!1},message:(e=\"\")=>\"string\"==typeof e?{ok:!0,payload:e}:{ok:!1,payload:\"\",message:`action.message must be a string. Received '${e}'`,required:!1},group:(e=\"\")=>\"string\"==typeof e?{ok:!0,payload:e}:{ok:!1,payload:null,message:`'${e}' invalid action.group value`,required:!1},callback:(e=\"\")=>\"string\"==typeof e?{ok:!0,payload:e}:{ok:!1,payload:null,message:`'${e}' invalid action.callback value`,required:!1},log:(e=!1)=>\"boolean\"==typeof e?{ok:!0,payload:e}:{ok:!1,payload:!1,message:`'${e}' invalid action.log value`,required:!1},middleware:(e=\"\")=>\"string\"==typeof e?{ok:!0,payload:e}:{ok:!1,payload:null,message:`'${e}' invalid action.middleware value`,required:!1},throttle:(e=0)=>Number.isInteger(e)?{ok:!0,payload:e}:{ok:!1,payload:100,message:`'${e}'  action.throttle value must be a number`,required:!1},debounce:(e=0)=>Number.isInteger(e)?{ok:!0,payload:e}:{ok:!1,payload:100,message:`'${e}'  action.debounce value must be a number`,required:!1},at:(e=0)=>({ok:!1,payload:e,message:`'${e}'  action.at is an experimental feature, not applied yet`,required:!1})},$e=function(e=crypto.randomUUID()){let t=!1;const r=async(e,t,r)=>{const o=Te(t,(async()=>{j.isHealthy()&&await i({...e,timeOfCreation:performance.now(),payload:r??e.payload})}),e.repeat||!0,e.id);return\"error\"===o.kind?{ok:!1,payload:null,message:o.error.message}:{ok:!0,payload:null,message:`Scheduled with breathing-adjusted interval: ${Math.round(t)}ms`}},o=async(e,t)=>{const r=e.priority?.level||\"medium\";if(!j.shouldAllowCall(r)){const{stress:e}=j.get();return{ok:!1,payload:null,message:`System under high stress (${(100*e.combined).toFixed(1)}%). Try later.`}}return a(e,t)},i=async e=>{if(!e?.type)throw new Error(\"Invalid IO object\");try{const r=ie(e.type)||ie(e.id);if(!r){const t=`${D} ${e.type}`;return s.error(t),{ok:!1,payload:null,message:t}}const o=performance.now(),i=fe({...e},r.fn);if(e.log&&s.info({...i,executionTime:performance.now()-o,timestamp:Date.now()}),i?.intraLink)try{const{id:e,payload:t}=i.intraLink;await n(e,t)}catch(t){s.error(`Linked action error: ${t}`)}return{ok:!0,payload:i,message:g}}catch(t){const e=t instanceof Error?t.message:String(t);return s.error(`Dispatch error: ${e}`),{ok:!1,payload:null,message:`Dispatch error: ${e}`}}},a=async(e,t)=>{try{if(e.throttle){const t=Date.now(),r=t-(re(e.id)?.lastExecutionTime||0);if(r<e.throttle)return{ok:!1,payload:null,message:`Throttled: ${e.throttle-r}ms remaining`}}const r=await i({...e,timeOfCreation:performance.now(),payload:t??e.payload});return j.recordCall(e.priority?.level),r}catch(r){return{ok:!1,payload:null,message:`Call failed: ${r instanceof Error?r.message:String(r)}`}}},n=async(e,i)=>{if(t)return{ok:!1,message:x,payload:null};if(!e?.trim())return{ok:!1,message:O,payload:null};const n=J(e.trim());return n?(async(e,t)=>{if(!e)return{ok:!1,payload:null,message:\"Invalid action\"};const{breathing:i,stress:n}=j.get();if(i.isRecuperating&&\"critical\"!==e.priority?.level)return{ok:!1,payload:null,message:`System recuperating (${(100*i.recuperationDepth).toFixed(1)}% depth). Try later.`};if(e.interval){const o=e.interval*(1+n.combined);return r(e,o,t)}return n.combined>=U.HIGH?o(e,t):a(e,t)})(n,i):{ok:!1,payload:null,message:`${S}: ${e}`}},c=()=>{if(!t)try{le().forEach((e=>{e.timeoutId&&clearTimeout(e.timeoutId)})),Ae(),ae(),Z(),j.reset(),t=!0,\"undefined\"!=typeof process&&process.exit&&process.exit(0)}catch(e){s.error(`Failed to shutdown gracefully: ${e}`),\"undefined\"!=typeof process&&process.exit&&process.exit(1)}};return\"undefined\"!=typeof window?window.addEventListener(\"beforeunload\",c):(process.on(\"SIGINT\",c),process.on(\"SIGTERM\",c),process.on(\"uncaughtException\",(e=>{console.error(\"Uncaught Exception:\",e),c()}))),{initialize:()=>(t=!1,Te(q.BASE,(async()=>{const e=j.get();j.updateBreath({cpu:e.system.cpu,memory:e.system.memory,eventLoop:e.system.eventLoop,isOverloaded:e.system.isOverloaded})}),!0),Re(),console.log(\"%c\"+N,\"background: rgb(151, 2, 151); color: white; display: block;\"),{ok:!0,payload:200,message:g}),call:n,action:e=>{if(t)s.error(m);else try{if(Array.isArray(e))e.forEach((e=>{const t=he({...e,type:e.type||e.id},Me);t.ok&&t.payload&&Q(t.payload)}));else{const t=he({...e,type:e.type||e.id},Me);t.ok&&t.payload&&Q(t.payload)}}catch(r){s.error(`Action registration failed: ${r}`)}},on:ve,shutdown:c,status:()=>(t?s.info({ok:!0,message:m}):s.info({ok:!0,message:p}),t),forget:e=>t?(s.error(x),!1):(we(e),K(e)),get:e=>{if(!t)return J(e);s.error(x)},pause:e=>{if(t)return void s.error(x);we(e);const r=le();if(e){const t=se(e);t&&ne({...t,status:\"paused\"})}else r.forEach((e=>{e&&ne({...e,status:\"paused\"})}))},resume:e=>{if(t)return void s.error(x);Re(e);const r=le();if(e){const t=se(e);t&&ne({...t,status:\"active\"})}else r.forEach((e=>{e&&ne({...e,status:\"active\"})}))},hasChanged:(e,r)=>t?(s.error(x),!1):ee(e,r),getPreviousPayload:e=>{if(!t)return te(e);s.error(x)},getBreathingState:()=>j.get().breathing,getPerformanceState:()=>{const e=j.get();return{totalProcessingTime:0,totalCallTime:0,totalStress:e.stress.combined,stress:e.stress.combined}},getMetrics:e=>t?{hibernating:!0,activeFormations:0,inRecuperation:!1,breathing:j.get().breathing,formations:[]}:{hibernating:!1,activeFormations:de().length,inRecuperation:!1,breathing:j.get().breathing,formations:le().filter((t=>t.id===e)).map((e=>({...e,breathingSync:1})))}}},Ce=$e(\"quantum-inceptions\");Ce.initialize();e.Cyre=$e,e.CyreLog=s,e.cyre=Ce,e.debounce=(e,t)=>{let r,o;const i=(...i)=>{o=i,clearTimeout(r),r=setTimeout((()=>e(...o)),t)};return i.cancel=()=>{clearTimeout(r)},i},e.default=\"./app\",e.isEqual=l,e.memoize=c,e.pipe=u,e.throttle=(e,t)=>{let r,o=null,i=0;const a=(...a)=>{r=a;const n=Date.now();i&&n<i+t?null===o&&(o=setTimeout((()=>{i=Date.now(),o=null,e(...r)}),t)):(i=n,e(...a))};return a.cancel=()=>{o&&(clearTimeout(o),o=null)},a},e.tryCatch=async e=>{try{return{kind:\"ok\",value:await e()}}catch(t){return{kind:\"error\",error:t instanceof Error?t:new Error(String(t))}}},e.version=\"3.1.2\",Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:\"Module\"}})}));\n//# sourceMappingURL=cyre.js.map\n","//src/config/holo-config.ts\n\n/**\n * H.O.L.O - C.A.R.O.U.S.E.L\n * Centralized configuration and constants\n */\n\n// Touch event constants\nexport const TOUCH_EVENTS = {\n  TOUCH_START: 'touch_start',\n  TOUCH_MOVE: 'touch_move',\n  TOUCH_END: 'touch_end',\n  DRAG_HORIZONTAL: 'drag_horizontal',\n  DRAG_VERTICAL: 'drag_vertical',\n  TRACK_VELOCITY: 'track_velocity',\n  PROCESS_TOUCH_END: 'process_touch_end'\n}\n\n// Standard event naming constants\nexport const EVENTS = {\n  // Initialization events\n  INIT_CAROUSEL: 'init_carousel',\n  INIT_DIMENSIONS: 'init_dimensions',\n\n  // State events\n  STATE_UPDATE: 'state_update',\n  STATE_BATCH_UPDATE: 'state_batch_update',\n\n  // Dimension events\n  REFRESH_CAROUSEL: 'refresh_carousel',\n  REFRESH_SCREEN: 'refresh_screen',\n\n  // Positioning events\n  SNAP_TO_POSITION: 'snap_to_position',\n  SNAP: 'snap',\n  TRANSFORM_COMPLETE: 'transform_complete',\n\n  // Navigation events\n  ANIMATE_FORWARD: 'animate_forward',\n  ANIMATE_BACKWARD: 'animate_backward',\n  NEXT_SLIDE: 'next_slide',\n  PREV_SLIDE: 'prev_slide',\n  FIRST_SLIDE: 'first_slide',\n  LAST_SLIDE: 'last_slide',\n  GO_TO_SLIDE: 'go_to_slide',\n  ACTIVATE: 'activate',\n  BRING_TO_FOCUS: 'bring_to_focus',\n\n  // Input events\n  WHEEL_EVENT: 'wheel_event',\n  KEYBOARD_EVENT: 'keyboard_event',\n\n  // Miscellaneous events\n  SHAKE: 'shake',\n\n  // Error handling\n  ERROR_HANDLER: 'error_handler',\n\n  // Performance events\n  PERFORMANCE_MONITOR: 'performance_monitor',\n  PERFORMANCE_OPTIMIZE: 'performance_optimize'\n}\n\n// Default animation settings\nexport const ANIMATION = {\n  DURATION: 600,\n  TIMING: 'cubic-bezier(0.215, 0.61, 0.355, 1)'\n}\n\n// Performance thresholds\nexport const PERFORMANCE = {\n  STRESS_THRESHOLD_HIGH: 0.8,\n  STRESS_THRESHOLD_MEDIUM: 0.5,\n  STRESS_HISTORY_SIZE: 10\n}\n\n// Default options\nexport const DEFAULT_IO_OPTIONS = {\n  enabled: 1, // Enable/disable carousel\n  wheel: 0, // Mouse wheel navigation\n  controller: 0, // Built-in controllers\n  drag: 1, // Mouse drag\n  swipe: 1, // Touch swipe\n  snap: 3, // Snap behavior (0=none, 1=loose, 2=medium, 3=strict)\n  focus: 1, // Focus on active slide\n  animate: 0, // Auto-animation (0=off)\n  animateDirection: 1, // Animation direction (1=forward, -1=backward)\n  duration: 600, // Animation duration (ms)\n  loop: 0, // Loop when reaching end (0=no, 1=yes, n=number of times)\n  orientation: 0, // Carousel orientation (0=horizontal, 1=vertical)\n  active: true, // Whether carousel is active\n  onClick: true, // Enable click events\n  onDoubleClick: false // Enable double-click events\n}\n\n// CSS class names (for consistency)\nexport const CSS_CLASSES = {\n  CAROUSEL: 'holo-carousel',\n  CONTAINER: 'holo-container',\n  ITEM: 'holo',\n  ACTIVE: 'active',\n  TRANSITION: 'transition',\n  LOADING: 'loading',\n  CONTROLS: 'holo-controls',\n  DOT: 'holo-dot',\n  NAV: 'holo-nav',\n  PREV: 'holo-prev',\n  NEXT: 'holo-next'\n}\n\nexport const DEFAULT_ANIMATION = {\n  DURATION: 1000,\n  TIMING: 1000\n}\n","//src/libs/holo-dom.ts\n\nimport {CyreLog} from 'cyre'\nimport type {HoloVirtual, HoloShadow, HoloDimensions} from '../types/interface'\nimport {_holo} from './holo-essentials'\nimport {EVENTS} from '../config/holo-config'\n\n/**\n * Check if DOM visibility APIs are available\n * Ensures we don't calculate dimensions when document is not visible\n */\nexport const isVisibilityAvailable = (): boolean => {\n  return (\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible'\n  )\n}\n\n/**\n * Get flex gap value from container element\n * Handles both inline styles and CSS variables\n */\nexport const getFlexGap = (container: HTMLElement): number => {\n  if (!container) return 0\n\n  try {\n    // Try to get computed style\n    const style = window.getComputedStyle(container)\n\n    // Check for gap property (most modern browsers)\n    if (style.gap && style.gap !== 'normal') {\n      // Parse gap value (remove 'px' or other units)\n      const gapValue = parseInt(style.gap, 10)\n      if (!isNaN(gapValue)) {\n        return gapValue\n      }\n    }\n\n    // Check for CSS variable (fallback)\n    const rootStyle = window.getComputedStyle(document.documentElement)\n    const gapVar = rootStyle.getPropertyValue('--holo-slide-gap')\n\n    if (gapVar) {\n      const gapValue = parseInt(gapVar, 10)\n      if (!isNaN(gapValue)) {\n        return gapValue\n      }\n    }\n\n    // Check for row-gap and column-gap separately\n    const rowGap =\n      style.rowGap && style.rowGap !== 'normal' ? parseInt(style.rowGap, 10) : 0\n    const columnGap =\n      style.columnGap && style.columnGap !== 'normal'\n        ? parseInt(style.columnGap, 10)\n        : 0\n\n    // For horizontal carousels, column-gap matters most\n    // For vertical carousels, row-gap matters most\n    return Math.max(rowGap || 0, columnGap || 0)\n  } catch (error) {\n    CyreLog.warn('Error detecting flex gap:', error)\n    return 0 // Default to no gap if detection fails\n  }\n}\n\n/**\n * Get element dimensions including margins with additional safeguards\n */\nexport const getElementDimensions = (element: HTMLElement): HoloDimensions => {\n  if (!element) return {width: 0, height: 0}\n\n  try {\n    // Try to get dimensions from inline styles first (most reliable)\n    let width = 0\n    let height = 0\n\n    // Get from inline style if available\n    if (element.style.width && element.style.height) {\n      width = parseInt(element.style.width, 10) || 0\n      height = parseInt(element.style.height, 10) || 0\n    }\n\n    // If inline styles didn't work, try getBoundingClientRect\n    if (width === 0 || height === 0) {\n      const rect = element.getBoundingClientRect()\n      width = rect.width || 0\n      height = rect.height || 0\n    }\n\n    // If still zero, try offsetWidth/offsetHeight\n    if (width === 0 || height === 0) {\n      width = element.offsetWidth || 0\n      height = element.offsetHeight || 0\n    }\n\n    // Get margins from computed style\n    const style = window.getComputedStyle(element)\n    const marginLeft = parseInt(style.marginLeft, 10) || 0\n    const marginRight = parseInt(style.marginRight, 10) || 0\n    const marginTop = parseInt(style.marginTop, 10) || 0\n    const marginBottom = parseInt(style.marginBottom, 10) || 0\n\n    // Add margins to dimensions\n    width += marginLeft + marginRight\n    height += marginTop + marginBottom\n\n    // Final safeguard against zero or NaN values\n    if (width <= 0 || isNaN(width)) width = 200\n    if (height <= 0 || isNaN(height)) height = 200\n\n    return {width, height}\n  } catch (error) {\n    CyreLog.error('Error calculating element dimensions:', error)\n    return {width: 200, height: 200} // Fallback dimensions\n  }\n}\n\n/**\n * Calculate carousel dimensions with improved robustness\n * This is the main dimension calculation function\n */\nexport const calculateCarouselDimensions = (\n  virtual: HoloVirtual,\n  shadow: HoloShadow\n): HoloVirtual | null => {\n  // Ensure we have DOM elements\n  if (!shadow?.container || !shadow?.carousel) {\n    CyreLog.error('Missing carousel DOM elements')\n    return null\n  }\n\n  try {\n    // Safety check for DOM readiness\n    if (\n      shadow.container.offsetWidth === 0 &&\n      shadow.container.offsetHeight === 0\n    ) {\n      CyreLog.warn(`DOM not ready for measurement, carousel: ${virtual.id}`)\n      return null\n    }\n\n    // Store original styles to restore later\n    const originalCarouselStyle = shadow.carousel.style.cssText\n    const originalContainerStyle = shadow.container.style.cssText\n\n    // Force visibility for measurement\n    shadow.carousel.style.visibility = 'visible'\n    shadow.carousel.style.display = 'block'\n    shadow.container.style.visibility = 'visible'\n    shadow.container.style.display = 'flex'\n\n    // Force layout recalculation\n    void shadow.carousel.offsetHeight\n    void shadow.container.offsetHeight\n\n    // Get all slides\n    const slides = Array.from(shadow.container.children) as HTMLElement[]\n\n    if (slides.length === 0) {\n      CyreLog.warn(`No slides found in carousel ${virtual.id}`)\n\n      // Restore original styles\n      shadow.carousel.style.cssText = originalCarouselStyle\n      shadow.container.style.cssText = originalContainerStyle\n\n      return null\n    }\n\n    // Get parent container dimensions with fallbacks\n    const parentWidth = Math.max(\n      shadow.carousel.parentElement?.clientWidth || 0,\n      shadow.carousel.clientWidth || 0,\n      window.innerWidth || 1024\n    )\n\n    const parentHeight = Math.max(\n      shadow.carousel.parentElement?.clientHeight || 0,\n      shadow.carousel.clientHeight || 0,\n      window.innerHeight || 768\n    )\n\n    // CRITICAL: Detect flex gap now and include it in calculations\n    const flexGap = getFlexGap(shadow.container)\n\n    // IMPROVED: More accurate calculation of total width and max slide dimensions\n    let totalWidth = 0\n    let totalHeight = 0\n    let maxSlideWidth = 0\n    let maxSlideHeight = 0\n\n    // Measure each slide individually to account for varying widths\n    slides.forEach((slide, index) => {\n      // Make sure the slide is visible for measurement\n      const originalSlideStyle = slide.style.cssText\n      slide.style.visibility = 'visible'\n      slide.style.display = 'inline-block'\n\n      // Force recalculation\n      void slide.offsetHeight\n\n      // Get computed style to include margins\n      const style = window.getComputedStyle(slide)\n      const marginLeft = parseInt(style.marginLeft) || 0\n      const marginRight = parseInt(style.marginRight) || 0\n      const marginTop = parseInt(style.marginTop) || 0\n      const marginBottom = parseInt(style.marginBottom) || 0\n\n      // Calculate slide dimensions with margins\n      const slideWidth = slide.offsetWidth + marginLeft + marginRight\n      const slideHeight = slide.offsetHeight + marginTop + marginBottom\n\n      // Track maximum dimensions\n      maxSlideWidth = Math.max(maxSlideWidth, slideWidth)\n      maxSlideHeight = Math.max(maxSlideHeight, slideHeight)\n\n      // Add to total dimensions - CRITICAL for scrolling all slides\n      totalWidth += slideWidth\n\n      // If not the last item, add gap for horizontal layout\n      if (index < slides.length - 1) {\n        totalWidth += flexGap\n      }\n\n      totalHeight += slideHeight\n\n      // If not the last item, add gap for vertical layout\n      if (index < slides.length - 1) {\n        totalHeight += flexGap\n      }\n\n      // Restore original style\n      slide.style.cssText = originalSlideStyle\n    })\n\n    // Add safety margin to ensure last slide is fully visible\n    totalWidth += maxSlideWidth * 0.1 // Add 10% of a slide width as padding\n\n    // Fallback if dimensions are still zero\n    if (maxSlideWidth === 0) maxSlideWidth = 200\n    if (maxSlideHeight === 0) maxSlideHeight = 200\n    if (totalWidth === 0)\n      totalWidth = (maxSlideWidth + flexGap) * slides.length - flexGap\n    if (totalHeight === 0)\n      totalHeight = (maxSlideHeight + flexGap) * slides.length - flexGap\n\n    // Calculate how many items can fit in view\n    const numberOfSlots = Math.min(\n      Math.max(1, Math.floor(parentWidth / (maxSlideWidth + flexGap))),\n      virtual.item.max || 10\n    )\n\n    // Calculate carousel dimensions (the viewport)\n    const carouselWidth = virtual.io.orientation\n      ? parentWidth\n      : Math.min(\n          numberOfSlots * (maxSlideWidth + flexGap) - flexGap,\n          parentWidth\n        )\n\n    const carouselHeight = virtual.io.orientation\n      ? Math.min(\n          numberOfSlots * (maxSlideHeight + flexGap) - flexGap,\n          parentHeight\n        )\n      : maxSlideHeight\n\n    // CRITICAL FIX: Calculate container dimensions to include ALL slides\n    // This ensures all slides are accessible by scrolling\n    const containerWidth = virtual.io.orientation\n      ? parentWidth // For vertical orientation, container width is just parent width\n      : totalWidth // For horizontal, it's the ACCURATE sum of all slide widths\n\n    const containerHeight = virtual.io.orientation\n      ? totalHeight // For vertical orientation, container height is the sum of all slide heights\n      : maxSlideHeight // For horizontal, it's just the maximum slide height\n\n    // CRITICAL FIX: Calculate end position to ensure all slides are accessible\n    const endOfSlidePosition = virtual.io.orientation\n      ? -Math.max(0, containerHeight - carouselHeight)\n      : -Math.max(0, containerWidth - carouselWidth)\n\n    // Store the detected flex gap in the virtual state for later use\n    const slideWithGap = {\n      width: maxSlideWidth + flexGap,\n      height: maxSlideHeight + flexGap,\n      actualWidth: maxSlideWidth,\n      actualHeight: maxSlideHeight,\n      gap: flexGap\n    }\n\n    // Restore original styles\n    shadow.carousel.style.cssText = originalCarouselStyle\n    shadow.container.style.cssText = originalContainerStyle\n\n    // Log the calculated dimensions for debugging\n    CyreLog.info(`Carousel ${virtual.id} dimensions calculated:`, {\n      slides: slides.length,\n      slideWidth: maxSlideWidth,\n      slideHeight: maxSlideHeight,\n      flexGap,\n      slideWithGapWidth: slideWithGap.width,\n      slideWithGapHeight: slideWithGap.height,\n      carouselWidth,\n      carouselHeight,\n      containerWidth,\n      containerHeight,\n      endOfSlidePosition,\n      totalWidth\n    })\n\n    // Create updated virtual state with new dimensions\n    return {\n      ...virtual,\n      item: {\n        ...virtual.item,\n        ...slideWithGap\n      },\n      numberOfSlots,\n      carousel: {\n        width: carouselWidth,\n        height: carouselHeight\n      },\n      container: {\n        width: containerWidth,\n        height: containerHeight\n      },\n      endOfSlidePosition,\n      noOfChildren: slides.length\n    }\n  } catch (error) {\n    CyreLog.error(`Error in dimension calculation for ${virtual.id}:`, error)\n    return null\n  }\n}\n\n/**\n * Force calculation of carousel dimensions and retry if needed\n */\nexport const forceCalculateCarouselDimensions = (\n  id: string\n): Promise<boolean> => {\n  return new Promise(resolve => {\n    if (!_holo[id]) {\n      CyreLog.error(`Carousel ${id} not found`)\n      resolve(false)\n      return\n    }\n\n    const state = _holo[id].getState\n    const {virtual, shadow} = state\n\n    // Log what we're about to do\n    CyreLog.info(`Force calculating dimensions for carousel ${id}`)\n\n    // Try to calculate dimensions immediately\n    const updatedVirtual = calculateCarouselDimensions(virtual, shadow)\n\n    if (updatedVirtual) {\n      // Store the updated dimensions\n      _holo[id].setDimension = {...updatedVirtual}\n\n      // Check if we have valid dimensions\n      if (\n        (virtual.io.orientation === 0 && updatedVirtual.item.width > 0) ||\n        (virtual.io.orientation === 1 && updatedVirtual.item.height > 0)\n      ) {\n        CyreLog.info(`Successfully calculated dimensions for ${id}:`, {\n          width: updatedVirtual.item.width,\n          height: updatedVirtual.item.height,\n          gap: updatedVirtual.item.gap\n        })\n        resolve(true)\n        return\n      }\n    }\n\n    // If we got here, we need to retry with a delay\n    CyreLog.warn(\n      `Initial dimension calculation failed for ${id}, retrying with delay`\n    )\n\n    // Try again with a delay to ensure DOM is ready\n    setTimeout(() => {\n      try {\n        // Force display to be set before calculating\n        if (shadow.carousel) {\n          shadow.carousel.style.display = 'block'\n        }\n        if (shadow.container) {\n          shadow.container.style.display = 'flex'\n        }\n\n        // Force a reflow\n        if (shadow.carousel) {\n          void shadow.carousel.offsetHeight\n        }\n        if (shadow.container) {\n          void shadow.container.offsetHeight\n        }\n\n        // Try again\n        const retryVirtual = calculateCarouselDimensions(virtual, shadow)\n\n        if (retryVirtual) {\n          // Store the updated dimensions\n          _holo[id].setDimension = {...retryVirtual}\n\n          CyreLog.info(`Retry succeeded for ${id}:`, {\n            width: retryVirtual.item.width,\n            height: retryVirtual.item.height,\n            gap: retryVirtual.item.gap\n          })\n\n          resolve(true)\n        } else {\n          CyreLog.error(`Dimension calculation failed for ${id} after retry`)\n          resolve(false)\n        }\n      } catch (error) {\n        CyreLog.error(`Error during retry for ${id}:`, error)\n        resolve(false)\n      }\n    }, 300) // Delay long enough for DOM to be ready\n  })\n}\n\n/**\n * Force refresh of all carousels to correct initialization issues\n */\nexport const forceRefreshAllCarousels = async (): Promise<void> => {\n  const carouselIds = Object.keys(_holo)\n  CyreLog.info(`Force refreshing ${carouselIds.length} carousels`)\n\n  // Process each carousel one at a time to avoid race conditions\n  for (const id of carouselIds) {\n    await forceCalculateCarouselDimensions(id)\n  }\n}\n\n/**\n * Get the current visible slide index\n */\nexport const getCurrentSlideIndex = (virtual: HoloVirtual): number => {\n  if (!virtual?.id) {\n    return 0\n  }\n\n  // Calculate based on transform position and item width/height\n  // Use width/height that includes gap for proper calculations\n  const slideDimension = virtual.io.orientation\n    ? virtual.item.height || 1\n    : virtual.item.width || 1\n\n  const position = virtual.io.orientation\n    ? Math.abs(virtual.transformY)\n    : Math.abs(virtual.transformX)\n\n  return Math.round(position / slideDimension)\n}\n\n/**\n * Get offsets for all slides in a carousel\n * With gap consideration for accurate positioning\n */\nexport const getSlideOffsets = (\n  virtual: HoloVirtual,\n  selectedElement?: HTMLElement\n): {offsets: number[]; selectedIndex: number} => {\n  if (!virtual?.id) {\n    return {offsets: [], selectedIndex: -1}\n  }\n\n  const container = document.querySelector(`#${virtual.id} .holo-container`)\n  if (!container) {\n    return {offsets: [], selectedIndex: -1}\n  }\n\n  const slides = Array.from(container.children) as HTMLElement[]\n  const gap = virtual.item.gap || 0\n\n  // Calculate offsets with gap consideration\n  const offsets = slides.map((slide, index) => {\n    if (virtual.io.orientation) {\n      // For vertical orientation\n      const baseOffset = index * (virtual.item.actualHeight + gap)\n      return baseOffset || 0\n    } else {\n      // For horizontal orientation\n      const baseOffset = index * (virtual.item.actualWidth + gap)\n      return baseOffset || 0\n    }\n  })\n\n  // Find the index of the selected element\n  let selectedIndex = -1\n  if (selectedElement) {\n    selectedIndex = slides.findIndex(slide => slide === selectedElement)\n  }\n\n  return {offsets, selectedIndex}\n}\n\n/**\n * Set active class on the current slide\n */\nexport const updateActiveSlide = (virtual: HoloVirtual): void => {\n  if (!virtual?.id) return\n\n  const currentIndex = getCurrentSlideIndex(virtual)\n  const container = document.querySelector(`#${virtual.id} .holo-container`)\n\n  if (!container) return\n\n  // Remove active class from all slides\n  const slides = Array.from(container.children)\n  slides.forEach((slide, index) => {\n    slide.classList.toggle('active', index === currentIndex)\n  })\n}\n","//src/components/orientation-handler.ts\n\nimport type {HoloVirtual} from '../types/interface'\nimport {snapToGrid} from '../libs/holo-essentials'\nimport {CyreLog} from 'cyre'\n\n/**\n * Handles horizontal transformations\n * Apply constraints and snap to grid functionality\n * Improved to handle all slides properly with flex gap\n */\nexport const transformX = (virtual: HoloVirtual): HoloVirtual => {\n  // Check for valid dimensions to avoid NaN errors\n  if (!virtual.item.width || isNaN(virtual.item.width)) {\n    CyreLog.warn(\n      `Missing width for horizontal carousel ${virtual.id}. Using fallback.`\n    )\n    virtual.item.width = 200\n  }\n\n  // Create a new object to maintain immutability\n  const updatedVirtual = {\n    ...virtual,\n    transformY: 0,\n    transformX:\n      virtual.io.snap && virtual.item.width\n        ? snapToGrid(virtual.transformX, virtual.item.width || 0)\n        : virtual.transformX\n  }\n\n  // CRITICAL: Make sure we have valid container and carousel dimensions\n  const containerWidth = virtual.container.width || 0\n  const carouselWidth = virtual.carousel.width || 0\n\n  // Calculate the true end position based on the FULL container width\n  const calculatedEndPosition = -Math.max(0, containerWidth - carouselWidth)\n\n  // IMPORTANT FIX: Always update the end position if it's different\n  // This prevents position drift as we scroll\n  updatedVirtual.endOfSlidePosition = calculatedEndPosition\n\n  // Apply boundary constraints\n  if (updatedVirtual.transformX >= 0) {\n    updatedVirtual.transformX = 0\n    updatedVirtual.endOfSlide = 1 // Left end of the carousel\n  } else if (updatedVirtual.transformX <= updatedVirtual.endOfSlidePosition) {\n    updatedVirtual.transformX = updatedVirtual.endOfSlidePosition\n    updatedVirtual.endOfSlide = -1 // Right end of the carousel\n  } else {\n    updatedVirtual.endOfSlide = 0 // In the middle of carousel\n  }\n\n  return updatedVirtual\n}\n\n/**\n * Handles vertical transformations\n * Apply constraints and snap to grid functionality\n * Improved to handle all slides properly with flex gap\n */\nexport const transformY = (virtual: HoloVirtual): HoloVirtual => {\n  // Check for valid dimensions first to avoid NaN errors\n  if (!virtual.item.height || isNaN(virtual.item.height)) {\n    CyreLog.warn(\n      `Missing height for vertical carousel ${virtual.id}. Using fallback.`\n    )\n    // Set a fallback height to prevent further issues\n    virtual.item.height = 200\n  }\n\n  // Create a new object to maintain immutability\n  const updatedVirtual = {\n    ...virtual,\n    transformX: 0, // Reset X transform for vertical carousels\n    transformY:\n      virtual.io.snap && virtual.item.height\n        ? snapToGrid(virtual.transformY, virtual.item.height || 0)\n        : virtual.transformY\n  }\n\n  // CRITICAL: Make sure we have valid container and carousel dimensions\n  const containerHeight = virtual.container.height || 0\n  const carouselHeight = virtual.carousel.height || 0\n\n  // Calculate the true end position based on the FULL container height\n  const calculatedEndPosition = -Math.max(0, containerHeight - carouselHeight)\n\n  // IMPORTANT FIX: Always update the end position if it's different\n  updatedVirtual.endOfSlidePosition = calculatedEndPosition\n\n  // Apply boundary constraints\n  if (updatedVirtual.transformY >= 0) {\n    updatedVirtual.transformY = 0\n    updatedVirtual.endOfSlide = 1 // Top end of the carousel\n  } else if (updatedVirtual.transformY <= updatedVirtual.endOfSlidePosition) {\n    updatedVirtual.transformY = updatedVirtual.endOfSlidePosition\n    updatedVirtual.endOfSlide = -1 // Bottom end of the carousel\n  } else {\n    updatedVirtual.endOfSlide = 0 // In the middle of carousel\n  }\n\n  return updatedVirtual\n}\n\n/**\n * Handles horizontal transformations (lightweight version)\n * Only applies boundary constraints without snapping\n */\nexport const transformXLite = (virtual: HoloVirtual): HoloVirtual => {\n  // Create a new object to maintain immutability\n  const updatedVirtual = {\n    ...virtual,\n    transformY: 0\n  }\n\n  // CRITICAL: Make sure we have valid container and carousel dimensions\n  const containerWidth = virtual.container.width || 0\n  const carouselWidth = virtual.carousel.width || 0\n\n  // Calculate the true end position based on the FULL container width\n  const calculatedEndPosition = -Math.max(0, containerWidth - carouselWidth)\n\n  // IMPORTANT FIX: Always update the end position if it's different\n  updatedVirtual.endOfSlidePosition = calculatedEndPosition\n\n  // Apply boundary constraints only\n  if (updatedVirtual.transformX >= 0) {\n    updatedVirtual.transformX = 0\n    updatedVirtual.endOfSlide = 1\n  } else if (updatedVirtual.transformX <= updatedVirtual.endOfSlidePosition) {\n    updatedVirtual.transformX = updatedVirtual.endOfSlidePosition\n    updatedVirtual.endOfSlide = -1\n  } else {\n    updatedVirtual.endOfSlide = 0\n  }\n\n  return updatedVirtual\n}\n\n/**\n * Handles vertical transformations (lightweight version)\n * Only applies boundary constraints without snapping\n */\nexport const transformYLite = (virtual: HoloVirtual): HoloVirtual => {\n  // Check for valid dimensions first\n  if (!virtual.item.height || isNaN(virtual.item.height)) {\n    CyreLog.warn(\n      `Missing height for vertical carousel ${virtual.id}. Using fallback.`\n    )\n    // Set a fallback height to prevent further issues\n    virtual.item.height = 200\n  }\n\n  // Create a new object to maintain immutability\n  const updatedVirtual = {\n    ...virtual,\n    transformX: 0\n  }\n\n  // CRITICAL: Make sure we have valid container and carousel dimensions\n  const containerHeight = virtual.container.height || 0\n  const carouselHeight = virtual.carousel.height || 0\n\n  // Calculate the true end position based on the FULL container height\n  const calculatedEndPosition = -Math.max(0, containerHeight - carouselHeight)\n\n  // IMPORTANT FIX: Always update the end position if it's different\n  updatedVirtual.endOfSlidePosition = calculatedEndPosition\n\n  // Apply boundary constraints only\n  if (updatedVirtual.transformY >= 0) {\n    updatedVirtual.transformY = 0\n    updatedVirtual.endOfSlide = 1\n  } else if (updatedVirtual.transformY <= updatedVirtual.endOfSlidePosition) {\n    updatedVirtual.transformY = updatedVirtual.endOfSlidePosition\n    updatedVirtual.endOfSlide = -1\n  } else {\n    updatedVirtual.endOfSlide = 0\n  }\n\n  return updatedVirtual\n}\n\n/**\n * Apply transformation based on orientation\n * @param virtual Virtual state\n * @param light Whether to use lightweight transform (no snapping)\n * @returns Updated virtual state with constraints applied\n */\nexport const applyTransform = (\n  virtual: HoloVirtual,\n  light: boolean = false\n): HoloVirtual => {\n  if (virtual.io.orientation) {\n    return light ? transformYLite(virtual) : transformY(virtual)\n  } else {\n    return light ? transformXLite(virtual) : transformX(virtual)\n  }\n}\n\n/**\n * Smart transform function that chooses the right transform based on context\n * @param virtual Virtual state\n * @param options Options for transformation\n * @returns Updated virtual state with transformation applied\n */\nexport const smartTransform = (\n  virtual: HoloVirtual,\n  options: {\n    snap?: boolean\n    light?: boolean\n    target?: number\n  } = {}\n): HoloVirtual => {\n  // Determine if we're going to a specific target position\n  if (options.target !== undefined) {\n    const isVertical = !!virtual.io.orientation\n    const itemSize = isVertical\n      ? virtual.item.height || 0\n      : virtual.item.width || 0\n\n    if (itemSize > 0) {\n      const targetPosition = -Math.abs(options.target * itemSize)\n\n      // Create a new state with the target position\n      const targetVirtual = {\n        ...virtual,\n        transformX: isVertical ? 0 : targetPosition,\n        transformY: isVertical ? targetPosition : 0\n      }\n\n      // Apply the appropriate transform to enforce boundaries\n      return applyTransform(targetVirtual, !options.snap)\n    }\n  }\n\n  // Otherwise just apply the normal transform\n  return applyTransform(virtual, options.light)\n}\n","//src/libs/holo-navigation.ts\n\nimport {cyre, CyreLog} from 'cyre'\nimport type {HoloVirtual} from '../types/interface'\nimport {_holo} from './holo-essentials'\nimport {EVENTS} from '../config/holo-config'\nimport {getSlideOffsets} from './holo-dom'\n\n/**\n * Centralized navigation functions for Holo carousel\n */\n\n/**\n * Go to next slide\n * @param virtual Virtual state\n */\nexport const goToNextSlide = (virtual: HoloVirtual): void => {\n  if (!virtual?.id) {\n    CyreLog.error('Cannot navigate: Invalid virtual state')\n    return\n  }\n\n  // Check if at the end\n  if (virtual.endOfSlide === -1 && !virtual.io.loop) {\n    // Already at the end and no loop configured\n    return\n  }\n\n  // Loop back to start if needed\n  if (virtual.endOfSlide === -1 && virtual.io.loop) {\n    cyre.call(EVENTS.FIRST_SLIDE, virtual)\n    return\n  }\n\n  // Calculate slide width/height based on orientation, including gap\n  const slideDimension = virtual.io.orientation\n    ? virtual.item.height || 0\n    : virtual.item.width || 0\n\n  if (!slideDimension) {\n    CyreLog.error(\n      `Cannot navigate: Missing dimension for carousel ${virtual.id}`\n    )\n    return\n  }\n\n  // IMPROVED: Calculate the current position and determine next slide position\n  const currentPosition = virtual.io.orientation\n    ? virtual.transformY\n    : virtual.transformX\n\n  const currentIndex = Math.round(Math.abs(currentPosition) / slideDimension)\n\n  // CRITICAL: Check if we're at the last slide\n  const maxIndex = (virtual.noOfChildren || 0) - 1\n\n  // Prevent going beyond the last slide\n  let nextIndex = currentIndex + 1\n  if (nextIndex > maxIndex && !virtual.io.loop) {\n    nextIndex = maxIndex\n  }\n\n  // Calculate the new transform position precisely\n  const newTransform = -Math.abs(nextIndex * slideDimension)\n\n  // Ensure we don't go beyond limits\n  const minPosition = virtual.endOfSlidePosition || 0\n  const newPosition = Math.max(newTransform, minPosition)\n\n  // Create updated virtual state with new position\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.io.orientation ? virtual.transformX : newPosition,\n    transformY: virtual.io.orientation ? newPosition : virtual.transformY\n  }\n\n  // Log navigation for debugging\n  CyreLog.info(\n    `Navigating to next slide: ${currentIndex} -> ${nextIndex}, position: ${currentPosition} -> ${newPosition}`\n  )\n\n  // Go to position\n  cyre.call(EVENTS.SNAP_TO_POSITION, updatedVirtual)\n}\n\n/**\n * Go to previous slide\n * @param virtual Virtual state\n */\nexport const goToPrevSlide = (virtual: HoloVirtual): void => {\n  if (!virtual?.id) {\n    CyreLog.error('Cannot navigate: Invalid virtual state')\n    return\n  }\n\n  // Check if at the beginning\n  if (virtual.endOfSlide === 1 && !virtual.io.loop) {\n    return\n  }\n\n  // Loop to end if needed\n  if (virtual.endOfSlide === 1 && virtual.io.loop) {\n    cyre.call(EVENTS.LAST_SLIDE, virtual)\n    return\n  }\n\n  // Calculate slide width/height based on orientation, including gap\n  const slideDimension = virtual.io.orientation\n    ? virtual.item.height || 0\n    : virtual.item.width || 0\n\n  if (!slideDimension) {\n    CyreLog.error(\n      `Cannot navigate: Missing dimension for carousel ${virtual.id}`\n    )\n    return\n  }\n\n  // IMPROVED: Calculate current and previous slide position\n  const currentPosition = virtual.io.orientation\n    ? virtual.transformY\n    : virtual.transformX\n\n  const currentIndex = Math.round(Math.abs(currentPosition) / slideDimension)\n\n  // Prevent going below the first slide\n  let prevIndex = currentIndex - 1\n  if (prevIndex < 0 && !virtual.io.loop) {\n    prevIndex = 0\n  }\n\n  // Calculate the new transform position\n  const newTransform = -Math.abs(prevIndex * slideDimension)\n\n  // Create updated virtual state with new position\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.io.orientation ? virtual.transformX : newTransform,\n    transformY: virtual.io.orientation ? newTransform : virtual.transformY\n  }\n\n  // Log navigation for debugging\n  CyreLog.info(`Navigating to previous slide: ${currentIndex} -> ${prevIndex}`)\n\n  // Go to position\n  cyre.call(EVENTS.SNAP_TO_POSITION, updatedVirtual)\n}\n\n/**\n * Go to first slide\n * @param virtual Virtual state\n */\nexport const goToFirstSlide = (virtual: HoloVirtual): void => {\n  if (!virtual?.id) {\n    CyreLog.error('Cannot navigate: Invalid virtual state')\n    return\n  }\n\n  // Create updated virtual state with start position\n  const updatedVirtual = {\n    ...virtual,\n    transformX: 0,\n    transformY: 0,\n    endOfSlide: 1 // At the start\n  }\n\n  // Go to position\n  cyre.call(EVENTS.SNAP_TO_POSITION, updatedVirtual)\n}\n\n/**\n * Go to last slide\n * @param virtual Virtual state\n */\nexport const goToLastSlide = (virtual: HoloVirtual): void => {\n  if (!virtual?.id) {\n    CyreLog.error('Cannot navigate: Invalid virtual state')\n    return\n  }\n\n  // IMPROVED: Calculate the position of the last slide directly\n  const slideDimension = virtual.io.orientation\n    ? virtual.item.height || 0\n    : virtual.item.width || 0\n\n  const maxIndex = (virtual.noOfChildren || 0) - 1\n  const lastSlidePosition = -Math.abs(maxIndex * slideDimension)\n\n  // Get absolute end position (from container dimensions)\n  const absoluteEndPosition = virtual.endOfSlidePosition || 0\n\n  // Use the greater (less negative) of the two to ensure we don't scroll too far\n  const finalPosition = Math.max(lastSlidePosition, absoluteEndPosition)\n\n  // Create updated virtual state with end position\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.io.orientation ? 0 : finalPosition,\n    transformY: virtual.io.orientation ? finalPosition : 0,\n    endOfSlide: -1 // At the end\n  }\n\n  // Go to position\n  cyre.call(EVENTS.SNAP_TO_POSITION, updatedVirtual)\n}\n\n/**\n * Go to specific slide index\n * @param virtual Virtual state\n * @param index Slide index to navigate to\n */\nexport const goToSlide = (virtual: HoloVirtual, index: number): void => {\n  if (!virtual?.id) {\n    CyreLog.error('Cannot navigate: Invalid virtual state')\n    return\n  }\n\n  // Calculate slide width/height based on orientation, including gap\n  const slideDimension = virtual.io.orientation\n    ? virtual.item.height || 0\n    : virtual.item.width || 0\n\n  if (!slideDimension) {\n    CyreLog.error(\n      `Cannot navigate: Missing dimension for carousel ${virtual.id}`\n    )\n    return\n  }\n\n  // IMPROVED: Check against max index\n  const maxIndex = (virtual.noOfChildren || 0) - 1\n  const safeIndex = Math.min(Math.max(0, index), maxIndex)\n\n  // Calculate the new transform position precisely\n  const newTransform = -Math.abs(safeIndex * slideDimension)\n\n  // Create updated virtual state with calculated position\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.io.orientation ? 0 : newTransform,\n    transformY: virtual.io.orientation ? newTransform : 0\n  }\n\n  // Log navigation for debugging\n  CyreLog.info(`Navigating to specific slide: ${safeIndex}`)\n\n  // Go to position\n  cyre.call(EVENTS.SNAP_TO_POSITION, updatedVirtual)\n}\n\n/**\n * Activate a specific slide (focus on click)\n * @param element The slide element\n * @param virtual Virtual state\n */\nexport const activateSlide = (\n  element: HTMLElement,\n  virtual: HoloVirtual\n): void => {\n  if (!element || !virtual?.id) {\n    CyreLog.error('Cannot activate slide: Invalid parameters')\n    return\n  }\n\n  // Get offset positions of all slides\n  const {offsets, selectedIndex} = getSlideOffsets(virtual, element)\n\n  if (selectedIndex === -1) {\n    CyreLog.error('Could not determine slide index')\n    return\n  }\n\n  // Update active class\n  document.querySelectorAll(`#${virtual.id} .holo`).forEach(el => {\n    el.classList.remove('active')\n  })\n  element.classList.add('active')\n\n  // Create updated virtual state with new position based on offset\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.io.orientation\n      ? virtual.transformX\n      : -Math.abs(offsets[selectedIndex]),\n    transformY: virtual.io.orientation\n      ? -Math.abs(offsets[selectedIndex])\n      : virtual.transformY\n  }\n\n  // Go to position\n  cyre.call(EVENTS.SNAP_TO_POSITION, updatedVirtual)\n}\n\n/**\n * Animate carousel in specified direction\n * @param virtual Virtual state\n * @param directionForward Direction of animation (true = forward, false = backward)\n */\nexport const animateCarousel = (\n  virtual: HoloVirtual,\n  directionForward: boolean = true\n): void => {\n  if (!virtual?.id) {\n    CyreLog.error('Cannot animate: Invalid virtual state')\n    return\n  }\n\n  if (directionForward) {\n    // Moving forward\n    if (virtual.endOfSlide === -1 && virtual.io.loop) {\n      // Loop back to start when at the end\n      goToFirstSlide(virtual)\n    } else {\n      // Go to next slide\n      goToNextSlide(virtual)\n    }\n  } else {\n    // Moving backward\n    if (virtual.endOfSlide === 1 && virtual.io.loop) {\n      // Loop to end when at the start\n      goToLastSlide(virtual)\n    } else {\n      // Go to previous slide\n      goToPrevSlide(virtual)\n    }\n  }\n}\n\n/**\n * Handle mouse wheel events for carousel navigation\n * @param e Wheel event\n * @param id Carousel ID\n */\nexport const handleWheel = (e: WheelEvent, id: string): void => {\n  e.preventDefault()\n  const virtual = _holo[id]?.getVirtual\n\n  if (!virtual) {\n    CyreLog.error(`Cannot handle wheel: Carousel ${id} not found`)\n    return\n  }\n\n  if (e.deltaY < 0) {\n    goToPrevSlide(virtual)\n  } else if (e.deltaY > 0) {\n    goToNextSlide(virtual)\n  }\n}\n","//src/core/holo-events.ts\n\nimport {cyre, CyreLog} from 'cyre'\nimport type {HoloVirtual, HoloShadow} from '../types/interface'\nimport {EVENTS, ANIMATION} from '../config/holo-config'\nimport {_holo} from '../libs/holo-essentials'\nimport {\n  calculateCarouselDimensions,\n  isVisibilityAvailable,\n  getCurrentSlideIndex\n} from '../libs/holo-dom'\nimport {applyTransform} from '../components/orientation-handler'\nimport {\n  goToFirstSlide,\n  goToLastSlide,\n  goToNextSlide,\n  goToPrevSlide,\n  goToSlide,\n  activateSlide,\n  animateCarousel\n} from '../libs/holo-navigation'\n\n/**\n * Creates instance-specific event IDs for this carousel\n * @param id Carousel ID\n * @returns Object with event IDs for this instance\n */\nexport const createEventIds = (id: string) => ({\n  animate: `animate_${id}`,\n  snap: `snap_${id}`,\n  prevSlide: `prev_slide_${id}`,\n  nextSlide: `next_slide_${id}`,\n  lastSlide: `last_slide_${id}`,\n  firstSlide: `first_slide_${id}`,\n  goToSlide: `go_to_slide_${id}`,\n  activate: `activate_${id}`,\n  refresh: `refresh_${id}`,\n  transform: `transform_${id}`,\n  stateUpdate: `state_update_${id}`,\n  dimensionUpdate: `dimension_update_${id}`,\n  error: `error_${id}`\n})\n\n/**\n * Safely calls a cyre event with fallback\n * @param eventId Primary event ID to call\n * @param payload Event payload\n * @param fallbackEventId Optional fallback event if primary fails\n * @returns Success indicator\n */\nexport const safeEventCall = (\n  eventId: string,\n  payload: any,\n  fallbackEventId?: string\n): boolean => {\n  try {\n    cyre.call(eventId, payload)\n    return true\n  } catch (error) {\n    CyreLog.warn(`Failed to call event ${eventId}`, error)\n\n    // Try fallback if provided\n    if (fallbackEventId) {\n      try {\n        CyreLog.info(`Attempting fallback to ${fallbackEventId}`)\n        cyre.call(fallbackEventId, payload)\n        return true\n      } catch (fallbackError) {\n        CyreLog.error(\n          `Fallback to ${fallbackEventId} also failed`,\n          fallbackError\n        )\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Initialize the event system with centralized event handlers\n * All events are organized into logical groups with reusable listener patterns\n */\nexport const initializeEventSystem = (): void => {\n  CyreLog.info('Initializing Holo event system')\n\n  // Register event handlers\n  registerStateEvents()\n  registerDimensionEvents()\n  registerNavigationEvents()\n  registerTransformEvents()\n  registerErrorEvents()\n  registerPerformanceEvents()\n\n  // Register global actions\n  registerGlobalActions()\n}\n\n/**\n * Register state update events\n * These handle state synchronization between virtual and DOM\n */\nfunction registerStateEvents() {\n  // State batch update for multiple changes\n  cyre.on(EVENTS.STATE_BATCH_UPDATE, payload => {\n    if (!payload || !payload.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'state_batch_update',\n          error: 'Invalid batch update payload',\n          data: payload\n        }\n      }\n    }\n\n    const {id, changes} = payload\n    const virtual = _holo[id]?.getVirtual\n\n    if (!virtual) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'state_batch_update',\n          error: `Carousel ${id} not found for batch update`,\n          id\n        }\n      }\n    }\n\n    // Apply all changes at once\n    _holo[id].setState = {...virtual, ...changes}\n\n    // Return positioned state to trigger snap or rendering\n    return {\n      id: EVENTS.SNAP_TO_POSITION,\n      payload: _holo[id].getVirtual\n    }\n  })\n\n  // Single state update for a specific property\n  cyre.on(EVENTS.STATE_UPDATE, payload => {\n    if (!payload || !payload.id || !payload.property) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'state_update',\n          error: 'Invalid state update payload',\n          data: payload\n        }\n      }\n    }\n\n    const {id, property, value} = payload\n    const virtual = _holo[id]?.getVirtual\n\n    if (!virtual) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'state_update',\n          error: `Carousel ${id} not found for state update`,\n          id\n        }\n      }\n    }\n\n    // Update the specific property\n    _holo[id].setState = {\n      ...virtual,\n      [property]: value\n    }\n\n    // Only return to snap if position-related property\n    if (['transformX', 'transformY'].includes(property)) {\n      return {\n        id: EVENTS.SNAP_TO_POSITION,\n        payload: _holo[id].getVirtual\n      }\n    }\n  })\n}\n\n/**\n * Register dimension calculation events\n * These handle calculating and updating carousel dimensions\n */\nfunction registerDimensionEvents() {\n  // Initial dimension calculation after DOM is ready\n  cyre.on(EVENTS.INIT_DIMENSIONS, payload => {\n    if (!payload || !payload.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'init_dimensions',\n          error: 'Invalid init dimensions payload',\n          data: payload\n        }\n      }\n    }\n\n    const {id} = payload\n\n    if (!_holo[id]) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'init_dimensions',\n          error: `Carousel ${id} not found for dimension init`,\n          id\n        }\n      }\n    }\n\n    const virtual = _holo[id].getVirtual\n    const shadow = _holo[id].getShadow\n\n    // Ensure we have DOM access\n    if (!isVisibilityAvailable()) {\n      // Queue for later when DOM is available\n      CyreLog.info(\n        `Deferring dimensions calculation for ${id} until DOM is visible`\n      )\n      setTimeout(() => cyre.call(EVENTS.INIT_DIMENSIONS, {id}), 100)\n      return\n    }\n\n    try {\n      // Calculate dimensions\n      const updatedVirtual = calculateCarouselDimensions(virtual, shadow)\n\n      if (updatedVirtual) {\n        // Store updated dimensions\n        _holo[id].setDimension = {...updatedVirtual}\n\n        // Continue to position carousel\n        return {\n          id: EVENTS.SNAP_TO_POSITION,\n          payload: updatedVirtual\n        }\n      }\n\n      // If we're still here, retry with a delay\n      setTimeout(() => {\n        cyre.call(EVENTS.INIT_DIMENSIONS, {id})\n      }, 300)\n    } catch (error) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'dimension_calculation',\n          id,\n          error\n        }\n      }\n    }\n  })\n\n  // Carousel refresh handler (recalculates dimensions)\n  cyre.on(\n    EVENTS.REFRESH_CAROUSEL,\n    (state: {virtual: HoloVirtual; shadow: HoloShadow}) => {\n      try {\n        const {virtual, shadow} = state\n\n        if (!virtual?.id) {\n          return {\n            id: EVENTS.ERROR_HANDLER,\n            payload: {\n              source: 'refresh_carousel',\n              error: 'Invalid virtual state',\n              data: {virtualId: virtual?.id}\n            }\n          }\n        }\n\n        // Reset container styles for fresh measurement\n        shadow.container.setAttribute('style', '')\n\n        // Calculate dimensions\n        const updatedVirtual = calculateCarouselDimensions(virtual, shadow)\n\n        if (updatedVirtual) {\n          // Store updated state\n          _holo[virtual.id].setDimension = {...updatedVirtual}\n\n          // Continue the event chain to positioning\n          return {\n            id: EVENTS.SNAP_TO_POSITION,\n            payload: updatedVirtual\n          }\n        } else {\n          // If calculation fails, retry with delay\n          setTimeout(() => {\n            cyre.call(EVENTS.REFRESH_CAROUSEL, _holo[virtual.id].getState)\n          }, 300)\n\n          return {\n            id: EVENTS.ERROR_HANDLER,\n            payload: {\n              source: 'refresh_carousel',\n              error: 'Failed to calculate dimensions',\n              id: virtual.id\n            }\n          }\n        }\n      } catch (error) {\n        return {\n          id: EVENTS.ERROR_HANDLER,\n          payload: {\n            source: 'refresh_carousel',\n            error: error instanceof Error ? error.message : 'Unknown error'\n          }\n        }\n      }\n    }\n  )\n\n  // Handle screen refresh (window resize)\n  cyre.on(EVENTS.REFRESH_SCREEN, () => {\n    // Get all carousel IDs\n    const carouselIds = Object.keys(_holo)\n\n    CyreLog.info(`Refreshing ${carouselIds.length} carousels`)\n\n    // Refresh each carousel\n    carouselIds.forEach(id => {\n      cyre.call(EVENTS.REFRESH_CAROUSEL, _holo[id].getState)\n    })\n  })\n}\n\n/**\n * Register navigation events\n * These handle movement between slides\n */\nfunction registerNavigationEvents() {\n  // Go to next slide\n  cyre.on(EVENTS.NEXT_SLIDE, (virtual: HoloVirtual) => {\n    if (!virtual?.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'next_slide',\n          error: 'Invalid virtual state in next slide'\n        }\n      }\n    }\n\n    // Use centralized navigation function\n    goToNextSlide(virtual)\n  })\n\n  // Go to previous slide\n  cyre.on(EVENTS.PREV_SLIDE, (virtual: HoloVirtual) => {\n    if (!virtual?.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'prev_slide',\n          error: 'Invalid virtual state in previous slide'\n        }\n      }\n    }\n\n    // Use centralized navigation function\n    goToPrevSlide(virtual)\n  })\n\n  // Go to first slide\n  cyre.on(EVENTS.FIRST_SLIDE, (virtual: HoloVirtual) => {\n    if (!virtual?.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'first_slide',\n          error: 'Invalid virtual state in first slide'\n        }\n      }\n    }\n\n    // Use centralized navigation function\n    goToFirstSlide(virtual)\n  })\n\n  // Go to last slide\n  cyre.on(EVENTS.LAST_SLIDE, (virtual: HoloVirtual) => {\n    if (!virtual?.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'last_slide',\n          error: 'Invalid virtual state in last slide'\n        }\n      }\n    }\n\n    // Use centralized navigation function\n    goToLastSlide(virtual)\n  })\n\n  // Go to specific slide index\n  cyre.on(\n    EVENTS.GO_TO_SLIDE,\n    (payload: {virtual: HoloVirtual; index: number}) => {\n      if (!payload || !payload.virtual || !payload.virtual.id) {\n        return {\n          id: EVENTS.ERROR_HANDLER,\n          payload: {\n            source: 'go_to_slide',\n            error: 'Invalid payload for go to slide'\n          }\n        }\n      }\n\n      // Use centralized navigation function\n      goToSlide(payload.virtual, payload.index)\n    }\n  )\n\n  // Activate specific slide (focus on click)\n  cyre.on(EVENTS.ACTIVATE, (payload: [HTMLElement, HoloVirtual]) => {\n    const [element, virtual] = payload\n\n    if (!element || !virtual || !virtual.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'activate',\n          error: 'Invalid activate payload'\n        }\n      }\n    }\n\n    // Use centralized navigation function\n    activateSlide(element, virtual)\n  })\n\n  // Auto-animate forward\n  cyre.on(EVENTS.ANIMATE_FORWARD, (virtual: HoloVirtual) => {\n    if (!virtual || !virtual.id) return\n\n    // Use centralized animation function with forward direction\n    animateCarousel(virtual, true)\n  })\n\n  // Auto-animate backward\n  cyre.on(EVENTS.ANIMATE_BACKWARD, (virtual: HoloVirtual) => {\n    if (!virtual || !virtual.id) return\n\n    // Use centralized animation function with backward direction\n    animateCarousel(virtual, false)\n  })\n}\n\n/**\n * Register transform events\n * These handle the actual DOM transformations\n */\nfunction registerTransformEvents() {\n  // Snap to position handler\n  cyre.on(EVENTS.SNAP_TO_POSITION, (virtual: HoloVirtual) => {\n    // Just forward to SNAP (simpler name and logic separation)\n    return {\n      id: EVENTS.SNAP,\n      payload: virtual\n    }\n  })\n\n  // Snap handler (final step in the chain)\n  cyre.on(EVENTS.SNAP, (virtual: HoloVirtual) => {\n    if (!virtual?.id) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'snap',\n          error: 'Invalid virtual state in SNAP event'\n        }\n      }\n    }\n\n    CyreLog.info(\n      `SNAP event for ${virtual.id}: transformX=${virtual.transformX}, transformY=${virtual.transformY}`\n    )\n\n    try {\n      // Validate dimensions first to prevent NaN errors\n      if (\n        virtual.io.orientation &&\n        (!virtual.item.height || isNaN(virtual.item.height))\n      ) {\n        CyreLog.warn(\n          `Carousel ${virtual.id} item height not calculated yet. Attempting to fix...`\n        )\n        // Try to recalculate dimensions\n        setTimeout(() => {\n          cyre.call(EVENTS.REFRESH_CAROUSEL, _holo[virtual.id].getState)\n        }, 100)\n        return\n      }\n\n      if (\n        !virtual.io.orientation &&\n        (!virtual.item.width || isNaN(virtual.item.width))\n      ) {\n        CyreLog.warn(\n          `Carousel ${virtual.id} item width not calculated yet. Attempting to fix...`\n        )\n        // Try to recalculate dimensions\n        setTimeout(() => {\n          cyre.call(EVENTS.REFRESH_CAROUSEL, _holo[virtual.id].getState)\n        }, 100)\n        return\n      }\n\n      // Update style to enable transitions\n      _holo[virtual.id].updateStyle = 1\n\n      // Apply orientation-specific transforms - THIS IS CRITICAL\n      const transformedVirtual = applyTransform(virtual)\n\n      // Safety check for NaN values\n      if (\n        isNaN(transformedVirtual.transformX) ||\n        isNaN(transformedVirtual.transformY)\n      ) {\n        CyreLog.error(\n          `NaN transform values detected for ${virtual.id}: X=${transformedVirtual.transformX}, Y=${transformedVirtual.transformY}`\n        )\n        // Try to repair\n        transformedVirtual.transformX = isNaN(transformedVirtual.transformX)\n          ? 0\n          : transformedVirtual.transformX\n        transformedVirtual.transformY = isNaN(transformedVirtual.transformY)\n          ? 0\n          : transformedVirtual.transformY\n      }\n\n      // Update state immutably\n      _holo[virtual.id].setState = {...transformedVirtual}\n\n      // CRITICAL: Direct DOM manipulation for immediate visual feedback\n      const carousel = document.getElementById(virtual.id)\n      if (carousel) {\n        const container = carousel.querySelector(\n          '.holo-container'\n        ) as HTMLElement\n        if (container) {\n          // Ensure we're never passing NaN values to CSS\n          const safeX = isNaN(transformedVirtual.transformX)\n            ? 0\n            : transformedVirtual.transformX\n          const safeY = isNaN(transformedVirtual.transformY)\n            ? 0\n            : transformedVirtual.transformY\n\n          container.style.transform = `translate3d(${safeX}px, ${safeY}px, 0px)`\n          CyreLog.debug(\n            `Applied direct transform: translate3d(${safeX}px, ${safeY}px, 0px)`\n          )\n        }\n      }\n\n      // Return the event for visualization or UI updates if needed\n      return {\n        id: EVENTS.TRANSFORM_COMPLETE,\n        payload: {\n          id: virtual.id,\n          position: getCurrentSlideIndex(transformedVirtual)\n        }\n      }\n    } catch (error) {\n      return {\n        id: EVENTS.ERROR_HANDLER,\n        payload: {\n          source: 'snap',\n          error: error instanceof Error ? error.message : 'Error in SNAP event',\n          id: virtual.id\n        }\n      }\n    }\n  })\n\n  // Transform complete handler (for UI updates)\n  cyre.on(EVENTS.TRANSFORM_COMPLETE, payload => {\n    // No additional action needed, but can be subscribed to by UI components\n    // for updating indicators or other UI elements\n  })\n}\n\n/**\n * Register error handling events\n */\nfunction registerErrorEvents() {\n  // Central error handler\n  cyre.on(EVENTS.ERROR_HANDLER, payload => {\n    const {source, error, id} = payload\n\n    CyreLog.error(`Holo Error [${source}]:`, error)\n\n    // For ID-specific errors, we can try recovery actions\n    if (id && _holo[id]) {\n      // Example recovery: Try to refresh the carousel\n      if (source === 'dimension_calculation') {\n        CyreLog.info(`Attempting to recover ${id} via refresh`)\n        setTimeout(\n          () => cyre.call(EVENTS.REFRESH_CAROUSEL, _holo[id].getState),\n          200\n        )\n      }\n    }\n  })\n}\n\n/**\n * Register performance monitoring events\n */\nfunction registerPerformanceEvents() {\n  // Performance monitor\n  cyre.on(EVENTS.PERFORMANCE_MONITOR, payload => {\n    const {id} = payload\n\n    if (!id || !_holo[id]) return\n\n    // Get Cyre performance metrics\n    const metrics = cyre.getPerformanceState()\n\n    // If stress is high, apply optimizations\n    if (metrics.stress > 0.8) {\n      return {\n        id: EVENTS.PERFORMANCE_OPTIMIZE,\n        payload: {\n          id,\n          stress: metrics.stress,\n          level: 'high'\n        }\n      }\n    } else if (metrics.stress > 0.5) {\n      return {\n        id: EVENTS.PERFORMANCE_OPTIMIZE,\n        payload: {\n          id,\n          stress: metrics.stress,\n          level: 'medium'\n        }\n      }\n    }\n  })\n\n  // Performance optimization\n  cyre.on(EVENTS.PERFORMANCE_OPTIMIZE, payload => {\n    const {id, level} = payload\n\n    if (!id || !_holo[id]) return\n\n    const virtual = _holo[id].getVirtual\n\n    // Apply optimizations based on level\n    switch (level) {\n      case 'high':\n        // Disable animations, increase throttling\n        _holo[id].setState = {\n          ...virtual,\n          io: {\n            ...virtual.io,\n            animate: 0,\n            wheel: 0,\n            duration: Math.max(400, virtual.io.duration || 0)\n          }\n        }\n        break\n      case 'medium':\n        // Slow down animations\n        _holo[id].setState = {\n          ...virtual,\n          io: {\n            ...virtual.io,\n            duration: Math.max(300, virtual.io.duration || 0)\n          }\n        }\n        break\n    }\n  })\n}\n\n/**\n * Register global actions with appropriate protection settings\n */\nfunction registerGlobalActions() {\n  cyre.action([\n    // Core state events\n    {\n      id: EVENTS.STATE_UPDATE,\n      detectChanges: true, // Only process if data changed\n      throttle: 50 // Prevent rapid updates\n    },\n    {\n      id: EVENTS.STATE_BATCH_UPDATE,\n      detectChanges: true\n    },\n\n    // Dimension events\n    {\n      id: EVENTS.INIT_DIMENSIONS,\n      throttle: 100\n    },\n    {\n      id: EVENTS.REFRESH_CAROUSEL,\n      throttle: 100\n    },\n    {\n      id: EVENTS.REFRESH_SCREEN,\n      throttle: 200 // Limit excessive resize handling\n    },\n\n    // Navigation events\n    {\n      id: EVENTS.NEXT_SLIDE,\n      throttle: 300 // Prevent rapid clicking\n    },\n    {\n      id: EVENTS.PREV_SLIDE,\n      throttle: 300\n    },\n    {\n      id: EVENTS.FIRST_SLIDE\n    },\n    {\n      id: EVENTS.LAST_SLIDE\n    },\n    {\n      id: EVENTS.GO_TO_SLIDE,\n      throttle: 300\n    },\n    {\n      id: EVENTS.ACTIVATE,\n      throttle: 300\n    },\n\n    // Transform events\n    {\n      id: EVENTS.SNAP_TO_POSITION,\n      throttle: 50\n    },\n    {\n      id: EVENTS.SNAP,\n      throttle: 50\n    },\n    {\n      id: EVENTS.TRANSFORM_COMPLETE\n    },\n\n    // Error handling\n    {\n      id: EVENTS.ERROR_HANDLER\n    },\n\n    // Performance events\n    {\n      id: EVENTS.PERFORMANCE_MONITOR,\n      interval: 5000, // Check every 5 seconds\n      repeat: true // Run continuously\n    },\n    {\n      id: EVENTS.PERFORMANCE_OPTIMIZE,\n      throttle: 1000 // Apply optimizations at most once per second\n    }\n  ])\n}\n\n// Update this function in holo-events.ts\n\n/**\n * Initialize event handlers for a specific carousel instance\n * Creates custom event IDs for this instance and links them to global handlers\n */\nexport const initializeInstanceEvents = (\n  id: string,\n  options: any = {}\n): void => {\n  if (!id || typeof id !== 'string') {\n    CyreLog.error(`Cannot initialize events for invalid carousel: ${id}`)\n    return\n  }\n\n  if (!_holo[id]) {\n    CyreLog.error(`Carousel ${id} not found for event initialization`)\n    return\n  }\n\n  const virtual = _holo[id].getVirtual\n\n  // Create instance-specific event IDs\n  const eventIds = createEventIds(id)\n\n  // Store these IDs in the virtual state for reference\n  _holo[id].setState = {\n    ...virtual,\n    eventIds\n  }\n\n  // IMPORTANT: Check for existing event handlers before registering new ones\n  // Prevents duplicate subscriptions when updating options\n\n  // Clean up any existing event handlers with these IDs first\n  Object.values(eventIds).forEach(eventId => {\n    if (eventId) {\n      cyre.forget(eventId)\n    }\n  })\n\n  // Register instance-specific handlers that forward to global ones\n  cyre.on(eventIds.animate, payload => {\n    CyreLog.info(`Animation event triggered for ${id}`)\n    return {\n      id:\n        virtual.io.animateDirection > 0\n          ? EVENTS.ANIMATE_FORWARD\n          : EVENTS.ANIMATE_BACKWARD,\n      payload\n    }\n  })\n\n  cyre.on(eventIds.snap, payload => {\n    return {\n      id: EVENTS.SNAP,\n      payload\n    }\n  })\n\n  cyre.on(eventIds.prevSlide, payload => {\n    return {\n      id: EVENTS.PREV_SLIDE,\n      payload\n    }\n  })\n\n  cyre.on(eventIds.nextSlide, payload => {\n    return {\n      id: EVENTS.NEXT_SLIDE,\n      payload\n    }\n  })\n\n  cyre.on(eventIds.firstSlide, payload => {\n    return {\n      id: EVENTS.FIRST_SLIDE,\n      payload\n    }\n  })\n\n  cyre.on(eventIds.lastSlide, payload => {\n    return {\n      id: EVENTS.LAST_SLIDE,\n      payload\n    }\n  })\n\n  cyre.on(eventIds.goToSlide, payload => {\n    return {\n      id: EVENTS.GO_TO_SLIDE,\n      payload: {\n        virtual: _holo[id].getVirtual,\n        index: payload.index\n      }\n    }\n  })\n\n  cyre.on(eventIds.activate, payload => {\n    return {\n      id: EVENTS.ACTIVATE,\n      payload\n    }\n  })\n\n  cyre.on(eventIds.refresh, payload => {\n    return {\n      id: EVENTS.REFRESH_CAROUSEL,\n      payload: payload || _holo[id].getState\n    }\n  })\n\n  cyre.on(eventIds.error, payload => {\n    return {\n      id: EVENTS.ERROR_HANDLER,\n      payload: {\n        ...payload,\n        id\n      }\n    }\n  })\n\n  // Configure instance-specific actions\n  cyre.action([\n    {\n      id: eventIds.animate,\n      interval: options.duration || ANIMATION.DURATION,\n      repeat: options.animate ? true : 0, // FIXED: Use true for infinite looping if animate is enabled\n      log: true // Enable logging for animation events\n    },\n    {\n      id: eventIds.snap,\n      throttle: 50\n    },\n    {\n      id: eventIds.prevSlide,\n      throttle: 300\n    },\n    {\n      id: eventIds.nextSlide,\n      throttle: 300\n    },\n    {\n      id: eventIds.firstSlide\n    },\n    {\n      id: eventIds.lastSlide\n    },\n    {\n      id: eventIds.goToSlide,\n      throttle: 300\n    },\n    {\n      id: eventIds.activate,\n      throttle: 300\n    },\n    {\n      id: eventIds.refresh,\n      throttle: 100\n    },\n    {\n      id: eventIds.error\n    }\n  ])\n\n  // FIXED: Start auto-animation only if specifically enabled\n  if (options.animate && options.animate !== 0) {\n    CyreLog.info(`Starting animation for carousel ${id}`)\n    cyre.call(eventIds.animate, _holo[id].getVirtual)\n  }\n\n  // Start performance monitoring if enabled\n  if (options.performance !== 0) {\n    // Schedule periodic performance checks\n    cyre.action({\n      id: `performance_monitor_${id}`,\n      interval: 5000,\n      repeat: true\n    })\n\n    cyre.on(`performance_monitor_${id}`, () => {\n      return {\n        id: EVENTS.PERFORMANCE_MONITOR,\n        payload: {id}\n      }\n    })\n\n    // Start monitoring\n    cyre.call(`performance_monitor_${id}`)\n  }\n}\n","//src/libs/holo-essentials.ts\n\nimport {cyre} from 'cyre'\nimport type {\n  HoloVirtual,\n  HoloDimensions,\n  HoloDatabase,\n  HoloIOOptions\n} from '../types/interface'\nimport {safeEventCall, createEventIds} from '../core/holo-events'\n\n/**\n * Main instance - holo database object\n */\nexport const _holo: HoloDatabase = {}\n\n/**\n * Snap position to grid\n */\nexport const snapToGrid = (position: number, gridSize: number): number => {\n  return Math.round(position / gridSize) * gridSize\n}\n\n/**\n * Determines if interaction was a click based on time elapsed\n */\nexport const isClickEvent = (timeElapsed: number): number => {\n  return timeElapsed < 250 ? 1 : 0 // Handle click, touch, double click or long-touch events\n}\n\n/**\n * Calculate swipe speed\n */\nexport const calculateSwipeSpeed = (\n  distance: number,\n  timeElapsed: number\n): number => {\n  return distance / timeElapsed\n}\n\n/**\n * Update IO parameters with immutable approach\n */\nexport const updateIOOptions = (\n  carouselParameter: HoloIOOptions,\n  io: Partial<HoloIOOptions> = {}\n): HoloIOOptions => {\n  // Filter valid attributes only\n  const validAttributes = Object.entries(io).reduce((valid, [key, value]) => {\n    if (key in carouselParameter) {\n      return {...valid, [key]: value}\n    }\n    console.error('@Holo: unknown carousel Parameter', key)\n    return valid\n  }, {})\n\n  // Return a new object with updated values\n  return {...carouselParameter, ...validAttributes}\n}\n\n/**\n * Get element dimensions including margins\n */\nexport const _getItemWidthHeight = (e: HTMLElement): HoloDimensions => {\n  if (!e) return {width: 0, height: 0}\n\n  const outer: HoloDimensions = {\n    width: e.offsetWidth,\n    height: e.offsetHeight\n  }\n\n  const style = window.getComputedStyle(e, null)\n\n  // Add margins to dimensions\n  const marginLeft = parseInt(style.marginLeft) || 0\n  const marginRight = parseInt(style.marginRight) || 0\n  const marginTop = parseInt(style.marginTop) || 0\n  const marginBottom = parseInt(style.marginBottom) || 0\n\n  outer.width += marginLeft + marginRight\n  outer.height += marginTop + marginBottom\n\n  return outer\n}\n\n/**\n * Calculate slider position boundaries\n */\nexport const calculateSliderPosition = (virtual: HoloVirtual): HoloVirtual => {\n  const updatedVirtual = {...virtual}\n\n  if (updatedVirtual.transformX >= 100) {\n    updatedVirtual.transformX = 100\n    updatedVirtual.endOfSlide = 1 // Left end of the carousel\n  } else if (\n    updatedVirtual.transformX + 100 <=\n    updatedVirtual.endOfSlidePosition!\n  ) {\n    updatedVirtual.transformX = updatedVirtual.endOfSlidePosition! - 100\n    updatedVirtual.endOfSlide = -1 // Right end of the carousel\n  } else {\n    updatedVirtual.endOfSlide = 0 // In the middle of carousel\n  }\n\n  return updatedVirtual\n}\n\n/**\n * Manage active/highlighted slides\n * Uses safeEventCall for better error handling\n */\nexport const activate = ([element, virtual]: [\n  HTMLElement,\n  HoloVirtual\n]): void => {\n  const updatedVirtual = {\n    ...virtual,\n    transformX: -Math.abs(element.offsetLeft)\n  }\n\n  // Get the event ID from virtual state or create consistent ID\n  const snapEventId = virtual.eventIds?.snap || `snap_${updatedVirtual.id}`\n\n  // Use safe event call with fallback to global SNAP event\n  safeEventCall(snapEventId, updatedVirtual, 'SNAP')\n  element.classList.add('active')\n}\n\n/**\n * Go to previous slide\n * Uses safeEventCall for better error handling\n */\nexport const prvSlide = (virtual: HoloVirtual): void => {\n  if (virtual.endOfSlide === 1) return // At left end, cannot go further left\n\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.transformX + (virtual.carousel.width || 0),\n    transformY: virtual.transformY + (virtual.carousel.height || 0)\n  }\n\n  // Get the event ID from virtual state or create consistent ID\n  const snapEventId = virtual.eventIds?.snap || `snap_${updatedVirtual.id}`\n\n  // Use safe event call with fallback to global SNAP event\n  safeEventCall(snapEventId, updatedVirtual, 'SNAP')\n}\n\n/**\n * Go to next slide\n * Uses safeEventCall for better error handling\n */\nexport const nxtSlide = (virtual: HoloVirtual): void => {\n  if (virtual.endOfSlide === -1) return // At right end, cannot go further right\n\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.transformX - (virtual.carousel.width || 0),\n    transformY: virtual.transformY - (virtual.carousel.height || 0)\n  }\n\n  // Get the event ID from virtual state or create consistent ID\n  const snapEventId = virtual.eventIds?.snap || `snap_${updatedVirtual.id}`\n\n  // Use safe event call with fallback to global SNAP event\n  safeEventCall(snapEventId, updatedVirtual, 'SNAP')\n}\n\n/**\n * Jump to first slide\n * Uses safeEventCall for better error handling\n */\nexport const firstSlide = (virtual: HoloVirtual): void => {\n  const updatedVirtual = {\n    ...virtual,\n    transformX: 0,\n    transformY: 0,\n    endOfSlide: 1\n  }\n\n  // Get the event ID from virtual state or create consistent ID\n  const snapEventId = virtual.eventIds?.snap || `snap_${updatedVirtual.id}`\n\n  // Use safe event call with fallback to global SNAP event\n  safeEventCall(snapEventId, updatedVirtual, 'SNAP')\n}\n\n/**\n * Jump to last slide\n * Uses safeEventCall for better error handling\n */\nexport const lastSlide = (virtual: HoloVirtual): void => {\n  const updatedVirtual = {\n    ...virtual,\n    transformX: virtual.endOfSlidePosition!,\n    transformY: virtual.endOfSlidePosition!,\n    endOfSlide: -1\n  }\n\n  // Get the event ID from virtual state or create consistent ID\n  const snapEventId = virtual.eventIds?.snap || `snap_${updatedVirtual.id}`\n\n  // Use safe event call with fallback to global SNAP event\n  safeEventCall(snapEventId, updatedVirtual, 'SNAP')\n}\n\n/**\n * Animate slides forward\n * Uses safeEventCall for better error handling\n */\nexport const animateSlideForward = (virtual: HoloVirtual): void => {\n  console.log('animating forward', virtual.id)\n\n  // Get event IDs from virtual state or create consistent IDs\n  const eventIds = virtual.eventIds || createEventIds(virtual.id)\n\n  if (virtual.endOfSlide === -1) {\n    safeEventCall(eventIds.firstSlide, virtual, 'first_slide')\n  } else {\n    safeEventCall(eventIds.nextSlide, virtual, 'next_slide')\n  }\n}\n\n/**\n * Animate slides backward\n * Uses safeEventCall for better error handling\n */\nexport const animateSlideBackward = (virtual: HoloVirtual): void => {\n  console.log('animating backward', virtual.id)\n\n  // Get event IDs from virtual state or create consistent IDs\n  const eventIds = virtual.eventIds || createEventIds(virtual.id)\n\n  if (virtual.endOfSlide === 1) {\n    safeEventCall(eventIds.lastSlide, virtual, 'last_slide')\n  } else {\n    safeEventCall(eventIds.prevSlide, virtual, 'prev_slide')\n  }\n}\n\n/**\n * Mouse wheel controller\n * Uses safeEventCall for better error handling\n */\nexport const wheeler = (e: WheelEvent, id: string): void => {\n  e.preventDefault()\n  const virtual = _holo[id].getVirtual\n\n  // Get event IDs from virtual state or create consistent IDs\n  const eventIds = virtual.eventIds || createEventIds(virtual.id)\n\n  if (e.deltaY < 0) {\n    safeEventCall(eventIds.prevSlide, virtual, 'prev_slide')\n  } else if (e.deltaY > 0) {\n    safeEventCall(eventIds.nextSlide, virtual, 'next_slide')\n  }\n}\n","//src/components/holo-touch.ts\n\nimport {cyre, CyreLog} from 'cyre'\nimport type {HoloVirtual} from '../types/interface'\nimport {_holo} from '../libs/holo-essentials'\nimport {applyTransform} from './orientation-handler'\nimport {TOUCH_EVENTS, EVENTS} from '../config/holo-config'\n\n/**\n * TouchState interface for tracking touch interactions\n */\ninterface TouchState {\n  id: string | null\n  virtual: HoloVirtual | null\n  startX: number\n  startY: number\n  currentX: number\n  currentY: number\n  lastX: number // Added to track direction more accurately\n  lastY: number // Added to track direction more accurately\n  distanceX: number\n  distanceY: number\n  directionX: number // Added to explicitly track direction (1 = right, -1 = left)\n  directionY: number // Added to explicitly track direction (1 = down, -1 = up)\n  velocityX: number\n  velocityY: number\n  startTransformX: number\n  startTransformY: number\n  pressed: boolean\n  startTime: number\n  multiplier: number\n  orientation: boolean\n  targetElement: HTMLElement | null\n  moved: boolean // Added to differentiate between taps and actual swipes\n}\n\n// Create shared touch state\nconst touchState: TouchState = {\n  id: null,\n  virtual: null,\n  startX: 0,\n  startY: 0,\n  currentX: 0,\n  currentY: 0,\n  lastX: 0,\n  lastY: 0,\n  distanceX: 0,\n  distanceY: 0,\n  directionX: 0,\n  directionY: 0,\n  velocityX: 0,\n  velocityY: 0,\n  startTransformX: 0,\n  startTransformY: 0,\n  pressed: false,\n  startTime: 0,\n  multiplier: 1.5,\n  orientation: false,\n  targetElement: null,\n  moved: false\n}\n\n/**\n * Initialize the touch system with Cyre events\n */\nexport const initializeTouchSystem = (): void => {\n  CyreLog.info('Initializing touch system')\n\n  try {\n    registerTouchEventHandlers()\n    registerDomEventListeners()\n  } catch (error) {\n    CyreLog.error('Error during touch system initialization:', error)\n  }\n}\n\n/**\n * Register touch event handlers and intralink chains\n */\nfunction registerTouchEventHandlers(): void {\n  // Touch start handler\n  cyre.on(\n    TOUCH_EVENTS.TOUCH_START,\n    (payload: {event: TouchEvent | MouseEvent; id: string}) => {\n      const {event, id} = payload\n\n      if (!_holo[id]?.getVirtual) {\n        CyreLog.error(`No carousel found with ID: ${id}`)\n        return\n      }\n\n      const virtual = _holo[id].getVirtual\n\n      // Check if touch is disabled in options\n      if (virtual.io.drag === 0 && virtual.io.swipe === 0) {\n        return\n      }\n\n      // Get initial touch/mouse position\n      const clientX =\n        'touches' in event ? event.touches[0].clientX : event.clientX\n      const clientY =\n        'touches' in event ? event.touches[0].clientY : event.clientY\n\n      // Update touch state\n      touchState.id = id\n      touchState.virtual = virtual\n      touchState.startX = clientX\n      touchState.startY = clientY\n      touchState.currentX = clientX\n      touchState.currentY = clientY\n      touchState.lastX = clientX\n      touchState.lastY = clientY\n      touchState.distanceX = 0\n      touchState.distanceY = 0\n      touchState.directionX = 0\n      touchState.directionY = 0\n      touchState.velocityX = 0\n      touchState.velocityY = 0\n      touchState.startTransformX = virtual.transformX\n      touchState.startTransformY = virtual.transformY\n      touchState.pressed = true\n      touchState.startTime = performance.now()\n      touchState.orientation = !!virtual.io.orientation\n      touchState.targetElement = event.target as HTMLElement\n      touchState.moved = false\n\n      // Disable transitions during drag\n      _holo[id].updateStyle = 0\n\n      // Continue chain to appropriate drag handler based on orientation\n      return {\n        id: touchState.orientation\n          ? TOUCH_EVENTS.DRAG_VERTICAL\n          : TOUCH_EVENTS.DRAG_HORIZONTAL,\n        payload: touchState\n      }\n    }\n  )\n\n  // Horizontal drag handler\n  cyre.on(TOUCH_EVENTS.DRAG_HORIZONTAL, (state: TouchState) => {\n    if (!state.pressed || !state.id || !state.virtual) {\n      return\n    }\n\n    // Calculate distance moved\n    const distanceX = state.startX - state.currentX\n\n    // Calculate direction explicitly by comparing with last position\n    // This is key to fixing the direction detection issues\n    if (state.currentX !== state.lastX) {\n      touchState.directionX = state.currentX < state.lastX ? 1 : -1 // 1 = right, -1 = left\n      touchState.lastX = state.currentX\n      touchState.moved = true // Mark that we've actually moved\n    }\n\n    // Update touch state\n    touchState.distanceX = distanceX\n\n    // Calculate new transform position\n    const newTransformX = state.startTransformX - distanceX * state.multiplier\n\n    // Update virtual state with light transform (no snapping during drag)\n    const updatedVirtual = {\n      ...state.virtual,\n      transformX: newTransformX\n    }\n\n    // Apply constraints through transform function\n    const transformedVirtual = applyTransform(updatedVirtual, true)\n\n    // Update state\n    _holo[state.id].setState = transformedVirtual\n\n    // Keep track of latest virtual state\n    touchState.virtual = transformedVirtual\n\n    // Keep tracking velocity during drag\n    return {\n      id: TOUCH_EVENTS.TRACK_VELOCITY,\n      payload: touchState\n    }\n  })\n\n  // Vertical drag handler\n  cyre.on(TOUCH_EVENTS.DRAG_VERTICAL, (state: TouchState) => {\n    if (!state.pressed || !state.id || !state.virtual) {\n      return\n    }\n\n    // Calculate distance moved\n    const distanceY = state.startY - state.currentY\n\n    // Calculate direction explicitly\n    if (state.currentY !== state.lastY) {\n      touchState.directionY = state.currentY < state.lastY ? 1 : -1 // 1 = down, -1 = up\n      touchState.lastY = state.currentY\n      touchState.moved = true // Mark that we've actually moved\n    }\n\n    // Update touch state\n    touchState.distanceY = distanceY\n\n    // Calculate new transform position\n    const newTransformY = state.startTransformY - distanceY * state.multiplier\n\n    // Update virtual state with light transform (no snapping during drag)\n    const updatedVirtual = {\n      ...state.virtual,\n      transformY: newTransformY\n    }\n\n    // Apply constraints through transform function\n    const transformedVirtual = applyTransform(updatedVirtual, true)\n\n    // Update state\n    _holo[state.id].setState = transformedVirtual\n\n    // Keep track of latest virtual state\n    touchState.virtual = transformedVirtual\n\n    // Keep tracking velocity during drag\n    return {\n      id: TOUCH_EVENTS.TRACK_VELOCITY,\n      payload: touchState\n    }\n  })\n\n  // Velocity tracking handler\n  cyre.on(TOUCH_EVENTS.TRACK_VELOCITY, (state: TouchState) => {\n    if (!state.pressed || !state.virtual) {\n      return\n    }\n\n    const elapsed = performance.now() - state.startTime\n\n    // Calculate velocity (pixels per millisecond)\n    touchState.velocityX = calculateSwipeSpeed(state.distanceX, elapsed)\n    touchState.velocityY = calculateSwipeSpeed(state.distanceY, elapsed)\n  })\n\n  // Touch end handler - CRITICAL FOR CORRECT BEHAVIOR\n  cyre.on(TOUCH_EVENTS.TOUCH_END, () => {\n    if (!touchState.id || !touchState.virtual) {\n      return\n    }\n\n    // Calculate time elapsed for click detection\n    const timeElapsed = performance.now() - touchState.startTime\n\n    // Save a copy of relevant data before resetting state\n    const touchData = {\n      id: touchState.id,\n      virtual: touchState.virtual,\n      targetElement: touchState.targetElement,\n      distanceX: touchState.distanceX,\n      distanceY: touchState.distanceY,\n      directionX: touchState.directionX,\n      directionY: touchState.directionY,\n      velocityX: touchState.velocityX,\n      velocityY: touchState.velocityY,\n      orientation: touchState.orientation,\n      startTime: touchState.startTime,\n      moved: touchState.moved // Include the moved flag to distinguish real swipes\n    }\n\n    // Reset pressed state immediately to prevent further movement\n    touchState.pressed = false\n\n    // Process the end of touch interaction\n    return {\n      id: TOUCH_EVENTS.PROCESS_TOUCH_END,\n      payload: {\n        touchState: touchData,\n        timeElapsed\n      }\n    }\n  })\n\n  // Process touch end - conditional intralink pattern\n  cyre.on(\n    TOUCH_EVENTS.PROCESS_TOUCH_END,\n    (payload: {touchState: any; timeElapsed: number}) => {\n      const {touchState, timeElapsed} = payload\n\n      if (!touchState.id || !touchState.virtual) {\n        return\n      }\n\n      const carouselId = touchState.id\n      const virtual = touchState.virtual\n      const targetElement = touchState.targetElement\n\n      // Determine velocity based on orientation\n      const velocity = touchState.orientation\n        ? touchState.velocityY\n        : touchState.velocityX\n      const absVelocity = Math.abs(velocity)\n\n      // Get explicit direction from tracked state\n      const direction = touchState.orientation\n        ? touchState.directionY\n        : touchState.directionX\n\n      // Get event IDs from virtual state or use defaults\n      const eventIds = virtual.eventIds || {\n        nextSlide: `next_slide_${carouselId}`,\n        prevSlide: `prev_slide_${carouselId}`,\n        snap: `snap_${carouselId}`,\n        activate: `activate_${carouselId}`\n      }\n\n      // Enable transitions for snapping\n      _holo[carouselId].updateStyle = 1\n\n      try {\n        // CONDITIONAL INTRALINK: different actions based on gesture\n\n        // Case 1: Swipe/flick (higher velocity) - IMPROVED DETECTION\n        if (absVelocity > 0.5 && touchState.moved && virtual.io.swipe !== 0) {\n          // Log the swipe for debugging\n          CyreLog.info(\n            `Swipe detected: direction=${direction}, velocity=${absVelocity}`\n          )\n\n          // Determine direction using our explicitly tracked direction\n          if (direction > 0) {\n            // Swipe right/down (positive direction)\n            return {\n              id: eventIds.nextSlide,\n              payload: virtual\n            }\n          } else if (direction < 0) {\n            // Swipe left/up (negative direction)\n            return {\n              id: eventIds.prevSlide,\n              payload: virtual\n            }\n          }\n        }\n        // Case 2: It's a tap/click (short duration, minimal movement)\n        else if (\n          isClickEvent(timeElapsed) &&\n          !touchState.moved && // Only count as click if we didn't really move\n          targetElement &&\n          virtual.io.onClick\n        ) {\n          // Find the closest carousel item\n          const closestItem = targetElement.closest('.holo')\n\n          if (closestItem) {\n            return {\n              id: eventIds.activate,\n              payload: [closestItem as HTMLElement, virtual]\n            }\n          }\n        }\n\n        // Default case: Snap to nearest position if snap is enabled\n        if (virtual.io.snap) {\n          return {\n            id: eventIds.snap,\n            payload: virtual\n          }\n        }\n\n        // Otherwise, apply transform constraints but don't snap\n        const constrainedVirtual = applyTransform(virtual, false)\n        _holo[carouselId].setState = constrainedVirtual\n      } catch (error) {\n        CyreLog.error('Error in touch end processing:', error)\n\n        // Fallback to snap (safest option)\n        return {\n          id: eventIds.snap,\n          payload: virtual\n        }\n      }\n    }\n  )\n\n  // Configure touch event actions\n  cyre.action([\n    {\n      id: TOUCH_EVENTS.TOUCH_START,\n      throttle: 50 // Prevent double triggers\n    },\n    {\n      id: TOUCH_EVENTS.DRAG_HORIZONTAL\n    },\n    {\n      id: TOUCH_EVENTS.DRAG_VERTICAL\n    },\n    {\n      id: TOUCH_EVENTS.TRACK_VELOCITY,\n      throttle: 100 // Don't need constant updates\n    },\n    {\n      id: TOUCH_EVENTS.TOUCH_END,\n      throttle: 50\n    },\n    {\n      id: TOUCH_EVENTS.PROCESS_TOUCH_END\n    }\n  ])\n}\n\n/**\n * Register document-level event listeners for touch/mouse\n */\nfunction registerDomEventListeners(): void {\n  // Mouse/touch move handler\n  const handlePointerMove = (e: MouseEvent | TouchEvent): void => {\n    if (!touchState.pressed || !touchState.id) return\n\n    // Prevent default to avoid page scrolling during drag\n    e.preventDefault()\n\n    // Update current position\n    if ('touches' in e && e.touches.length > 0) {\n      touchState.currentX = e.touches[0].clientX\n      touchState.currentY = e.touches[0].clientY\n    } else if ('clientX' in e) {\n      touchState.currentX = e.clientX\n      touchState.currentY = e.clientY\n    } else {\n      // If no valid coordinates, end the touch interaction\n      handlePointerEnd(e)\n      return\n    }\n\n    // Call appropriate drag event based on orientation\n    cyre.call(\n      touchState.orientation\n        ? TOUCH_EVENTS.DRAG_VERTICAL\n        : TOUCH_EVENTS.DRAG_HORIZONTAL,\n      touchState\n    )\n  }\n\n  // Mouse/touch end handler - IMPORTANT FIX HERE\n  const handlePointerEnd = (e: MouseEvent | TouchEvent): void => {\n    // Only process if we're in a pressed state\n    if (!touchState.pressed) return\n\n    // Prevent default behavior\n    e.preventDefault()\n\n    // Call the touch end event\n    cyre.call(TOUCH_EVENTS.TOUCH_END)\n  }\n\n  // Add document-level listeners to catch events even if they occur outside the element\n  document.addEventListener('mousemove', handlePointerMove, {passive: false})\n  document.addEventListener('touchmove', handlePointerMove, {passive: false})\n  document.addEventListener('mouseup', handlePointerEnd, {passive: false})\n  document.addEventListener('touchend', handlePointerEnd, {passive: false})\n  document.addEventListener('touchcancel', handlePointerEnd, {passive: false})\n  document.addEventListener('mouseleave', handlePointerEnd, {passive: false})\n}\n\n/**\n * Public handler for touch/mouse start events\n */\nexport const handleTouchStart = (\n  event: MouseEvent | TouchEvent,\n  id: string\n): void => {\n  event.preventDefault()\n\n  // Call the touch start event with event info and carousel ID\n  cyre.call(TOUCH_EVENTS.TOUCH_START, {event, id})\n}\n\n/**\n * Calculates swipe speed from distance and time\n */\nconst calculateSwipeSpeed = (distance: number, timeElapsed: number): number => {\n  return distance / (timeElapsed || 1)\n}\n\n/**\n * Determines if interaction was a click based on time elapsed\n */\nconst isClickEvent = (timeElapsed: number): boolean => {\n  return timeElapsed < 300\n}\n","//src/components/holo-io-manager.ts\n\nimport {cyre, CyreLog} from 'cyre'\nimport type {HoloVirtual, HoloShadow} from '../types/interface'\nimport {handleTouchStart} from './holo-touch'\nimport {handleWheel} from '../libs/holo-navigation'\nimport {initializeInstanceEvents} from '../core/holo-events'\nimport {EVENTS} from '../config/holo-config'\n\n/**\n * H.O.L.O - C.A.R.O.U.S.E.L\n * IO manager\n * Setup input/output event handling for a carousel instance\n */\nexport const setupIOManager = (\n  virtual: HoloVirtual,\n  shadow: HoloShadow\n): void => {\n  if (!virtual) {\n    CyreLog.error('@Holo: Major malfunctions - Virtual state is missing')\n    return\n  }\n\n  if (!virtual.id || typeof virtual.id !== 'string') {\n    CyreLog.error('@Holo: Virtual state has no valid ID', virtual)\n    return\n  }\n\n  // Initialize instance-specific events using the enhanced event system\n  try {\n    initializeInstanceEvents(virtual.id, virtual.io)\n  } catch (error) {\n    CyreLog.error(\n      `Error initializing events for carousel ${virtual.id}:`,\n      error\n    )\n  }\n\n  // Setup DOM event handlers if enabled\n  if (virtual.io.enabled) {\n    setupDomEventHandlers(virtual, shadow)\n  }\n\n  // Initial refresh\n  cyre.call(EVENTS.REFRESH_CAROUSEL, {virtual, shadow})\n}\n\n/**\n * Setup DOM event handlers for user interaction\n */\nconst setupDomEventHandlers = (\n  virtual: HoloVirtual,\n  shadow: HoloShadow\n): void => {\n  if (!virtual.id || !shadow || !shadow.carousel || !shadow.container) {\n    CyreLog.error(\n      `Cannot setup DOM handlers for carousel ${virtual?.id}: Invalid shadow elements`\n    )\n    return\n  }\n\n  CyreLog.info(`Setting up DOM handlers for carousel ${virtual.id}`)\n\n  // Get event IDs from virtual\n  const eventIds = virtual.eventIds || {}\n\n  // Mouse drag handler\n  if (virtual.io.drag) {\n    const handleMouseDown = (e: MouseEvent): void => {\n      e.preventDefault()\n      e.stopPropagation()\n      handleTouchStart(e, virtual.id)\n\n      // Log for debugging\n      CyreLog.debug(`Mouse down detected on carousel ${virtual.id}`)\n    }\n\n    shadow.container.addEventListener('mousedown', handleMouseDown, {\n      passive: false\n    })\n\n    // Add click handlers to individual slides\n    const slideElements = shadow.container.querySelectorAll('.holo')\n    slideElements.forEach((slide, index) => {\n      slide.addEventListener(\n        'click',\n        e => {\n          e.preventDefault()\n          e.stopPropagation()\n\n          CyreLog.debug(`Slide ${index} clicked in carousel ${virtual.id}`)\n\n          if (eventIds.activate) {\n            cyre.call(eventIds.activate, [slide as HTMLElement, virtual])\n          }\n        },\n        {passive: false}\n      )\n    })\n  }\n\n  // Touch drag handler\n  if (virtual.io.drag) {\n    const touchStartHandler = (e: TouchEvent): void => {\n      e.preventDefault()\n      e.stopPropagation()\n      handleTouchStart(e, virtual.id)\n\n      // Log for debugging\n      CyreLog.debug(`Touch start detected on carousel ${virtual.id}`)\n    }\n\n    shadow.container.addEventListener('touchstart', touchStartHandler, {\n      passive: false\n    })\n  }\n\n  // Mouse wheel handler\n  if (virtual.io.wheel) {\n    const wheelHandler = (e: WheelEvent): void => {\n      e.preventDefault()\n      e.stopPropagation()\n      handleWheel(e, virtual.id)\n\n      // Log for debugging\n      CyreLog.debug(`Wheel event detected on carousel ${virtual.id}`)\n    }\n\n    shadow.carousel.addEventListener('wheel', wheelHandler, {passive: false})\n  }\n\n  // Navigation buttons\n  const prevButton = shadow.carousel.querySelector('.holo-prev')\n  const nextButton = shadow.carousel.querySelector('.holo-next')\n\n  if (prevButton) {\n    prevButton.addEventListener('click', e => {\n      e.preventDefault()\n      e.stopPropagation()\n      if (eventIds.prevSlide) {\n        cyre.call(eventIds.prevSlide, virtual)\n      }\n    })\n  }\n\n  if (nextButton) {\n    nextButton.addEventListener('click', e => {\n      e.preventDefault()\n      e.stopPropagation()\n      if (eventIds.nextSlide) {\n        cyre.call(eventIds.nextSlide, virtual)\n      }\n    })\n  }\n\n  // Animation handler - start animation if enabled\n  if (virtual.io.animate && eventIds.animate) {\n    cyre.call(eventIds.animate, virtual)\n  }\n\n  // Resize handler\n  const handleResize = (): void => {\n    cyre.call(EVENTS.REFRESH_CAROUSEL, {virtual, shadow})\n  }\n\n  // Add resize listener to window\n  window.addEventListener('resize', handleResize, {passive: true})\n\n  // Also refresh on orientation change\n  window.addEventListener('orientationchange', handleResize, {passive: true})\n}\n\nexport default setupIOManager\n","// src/core/holo-state.ts\n\nimport {cyre} from 'cyre'\nimport type {\n  HoloVirtual,\n  HoloShadow,\n  HoloInstance,\n  HoloIOOptions\n} from '../types/interface'\nimport {DEFAULT_IO_OPTIONS, ANIMATION, EVENTS} from '../config/holo-config'\nimport {createEventIds} from '../core/holo-events'\n\n/**\n * Create default virtual state with immutable pattern\n */\nexport const createDefaultVirtual = (id: string = ''): HoloVirtual => {\n  return {\n    id,\n    carousel: {},\n    container: {},\n    io: createDefaultIOOptions(id),\n    title: null,\n    description: null,\n    duration: ANIMATION.DURATION,\n    transitionTiming: ANIMATION.TIMING,\n    transformX: 0,\n    transformY: 0,\n    transformZ: 0,\n    numberOfSlots: 0,\n    endOfSlide: 0,\n    endOfSlidePosition: 0,\n    item: {\n      max: 8,\n      width: 0,\n      height: 0,\n      min: 1\n    },\n    noOfChildren: 0,\n    startNumber: 0,\n    // Add consistent event IDs\n    eventIds: createEventIds(id)\n  }\n}\n\n/**\n * Create default IO options\n */\nexport const createDefaultIOOptions = (id: string = ''): HoloIOOptions => {\n  return {\n    ...DEFAULT_IO_OPTIONS,\n    id\n  }\n}\n\n/**\n * Create default shadow state\n */\nexport const createDefaultShadow = (): HoloShadow => {\n  return {\n    carousel: {} as HTMLElement,\n    container: {} as HTMLElement\n  }\n}\n\n/**\n * Create an enhanced Holo instance with improved state management\n */\nexport const createHoloInstance = (\n  slide: HTMLElement,\n  io: Partial<HoloIOOptions> = {}\n): HoloInstance => {\n  // Ensure valid ID\n  const id = slide.id || `holo-${Date.now()}`\n  slide.id = id // Apply ID to element if it didn't have one\n\n  // Find container or create one if missing\n  const container = slide.getElementsByClassName(\n    'holo-container'\n  )[0] as HTMLElement\n\n  if (!container) {\n    console.error('@Holo: holo-container not found in:', id)\n    throw new Error('Missing holo-container element')\n  }\n\n  // Create shadow DOM references\n  const shadow: HoloShadow = {\n    carousel: slide,\n    container\n  }\n\n  // Create initial virtual state\n  const virtual = createDefaultVirtual(id)\n\n  // Apply custom IO options\n  virtual.io = {\n    ...virtual.io,\n    ...io,\n    id\n  }\n\n  // Get initial dimensions\n  const carouselWidth = shadow.carousel.clientWidth || 0\n  const carouselHeight = shadow.carousel.clientHeight || 0\n  const containerWidth = shadow.container.clientWidth || 0\n  const containerHeight = shadow.container.clientHeight || 0\n  const childrenCount = shadow.container.children.length || 0\n\n  // Initialize virtual state with dimensions\n  const initializedVirtual = {\n    ...virtual,\n    carousel: {\n      width: carouselWidth,\n      height: carouselHeight\n    },\n    container: {\n      width: containerWidth,\n      height: containerHeight\n    },\n    noOfChildren: childrenCount,\n    startNumber: 0,\n    // Calculate end position based on orientation\n    endOfSlidePosition: virtual.io.orientation\n      ? -Math.max(0, containerHeight - carouselHeight)\n      : -Math.max(0, containerWidth - carouselWidth)\n  }\n\n  // Register subscriber for state changes (prevent \"no subscriber\" error)\n  const stateUpdatedId = `state_updated_${id}`\n\n  // Add a simple subscriber to prevent no-subscriber errors\n  cyre.on(stateUpdatedId, state => {\n    // Do nothing - just a placeholder to avoid console errors\n    return undefined\n  })\n\n  // Register action with throttling and change detection\n  cyre.action({\n    id: stateUpdatedId,\n    throttle: 16, // ~60fps\n    detectChanges: true // Only process if actual changes\n  })\n\n  // Create the interface for the instance with pure functions\n  const instance: HoloInstance = {\n    virtual: initializedVirtual,\n    shadow,\n\n    // Getters - Return immutable copies\n    get getVirtual(): HoloVirtual {\n      return {...this.virtual}\n    },\n\n    get getShadow(): HoloShadow {\n      return this.shadow\n    },\n\n    get getState() {\n      return {\n        virtual: this.getVirtual,\n        shadow: this.getShadow\n      }\n    },\n\n    get getDimensions() {\n      return {\n        car: {\n          w: this.shadow.carousel.clientWidth || 0,\n          h: this.shadow.carousel.clientHeight || 0\n        },\n        con: {\n          w: this.shadow.container.clientWidth || 0,\n          h: this.shadow.container.clientHeight || 0,\n          x: this.virtual.transformX,\n          y: this.virtual.transformY,\n          z: this.virtual.transformZ\n        }\n      }\n    },\n\n    // Setters - Update state and DOM with side effects\n    set setState(updatedVirtual: HoloVirtual) {\n      if (!updatedVirtual) return\n\n      // Update virtual state immutably\n      this.virtual = {...this.virtual, ...updatedVirtual}\n\n      // Update DOM with side effect\n      this.updateDOMTransform()\n\n      // Notify about state update\n      cyre.call(`state_updated_${id}`, this.virtual)\n    },\n\n    set setDimension(updatedVirtual: HoloVirtual) {\n      if (!updatedVirtual) return\n\n      // Update virtual state immutably\n      this.virtual = {...this.virtual, ...updatedVirtual}\n\n      // Update DOM dimensions with side effect\n      this.updateDOMDimensions()\n    },\n\n    set updateStyle(on: number) {\n      // Update transition style based on flag\n      this.updateTransitionStyle(on === 1)\n    },\n\n    // Helper methods to update DOM\n    updateDOMTransform() {\n      if (!this.shadow.container) return\n\n      // Apply transform to container\n      this.shadow.container.style.transform = `translate3d(${this.virtual.transformX}px, ${this.virtual.transformY}px, ${this.virtual.transformZ}px)`\n    },\n\n    updateDOMDimensions() {\n      if (!this.shadow.carousel) return\n\n      // Apply dimensions based on orientation\n      if (this.virtual.io.orientation) {\n        this.shadow.carousel.style.height = `${this.virtual.carousel.height}px`\n      } else {\n        this.shadow.carousel.style.width = `${this.virtual.carousel.width}px`\n      }\n    },\n\n    updateTransitionStyle(enableTransition: boolean) {\n      if (!this.shadow.container) return\n\n      // Set transition properties\n      if (enableTransition) {\n        this.shadow.container.style.transitionDuration = `${this.virtual.duration}ms`\n        this.shadow.container.style.transitionTimingFunction =\n          this.virtual.transitionTiming\n      } else {\n        this.shadow.container.style.transitionDuration = '0ms'\n        this.shadow.container.style.transitionTimingFunction = 'linear'\n      }\n    }\n  }\n\n  return instance\n}\n\n/**\n * Update Holo instance with new options\n */\nexport const updateHoloInstance = (\n  instance: HoloInstance,\n  options: Partial<HoloIOOptions>\n): HoloInstance => {\n  if (!instance || !instance.virtual) {\n    console.error('@Holo: Cannot update invalid instance')\n    return instance\n  }\n\n  // Filter valid attributes only\n  const validOptions = Object.entries(options).reduce((valid, [key, value]) => {\n    if (key in instance.virtual.io) {\n      return {...valid, [key]: value}\n    }\n    console.warn('@Holo: unknown carousel parameter:', key)\n    return valid\n  }, {})\n\n  // Update IO options immutably\n  const updatedIO = {\n    ...instance.virtual.io,\n    ...validOptions\n  }\n\n  // Update virtual state\n  instance.setState = {\n    ...instance.getVirtual,\n    io: updatedIO\n  }\n\n  return instance\n}\n","//src/components/holo-create-element.ts\n\nimport {CyreLog} from 'cyre'\nimport type {HoloIOOptions} from '../types/interface'\nimport {_holo} from '../libs/holo-essentials'\nimport setupIOManager from './holo-io-manager'\nimport {createHoloInstance} from '../core/holo-state'\n\n/**\n * Create and initialize a carousel element\n * @param slide - DOM element to convert to carousel\n * @param io - Input/Output options\n */\nexport const holoCreateElement = (\n  slide: HTMLElement,\n  io: Partial<HoloIOOptions> = {}\n): string | null => {\n  if (!slide || !slide.nodeType) {\n    console.error('@Holo: Invalid DOM element provided')\n    return null\n  }\n\n  // Ensure slide has an ID\n  if (!slide.id) {\n    slide.id = `holo-${Date.now()}`\n  }\n\n  try {\n    // Create and register the carousel instance\n    _holo[slide.id] = createHoloInstance(slide, io)\n\n    console.log('@Holo: Created carousel:', slide.id)\n\n    // Setup event handlers\n    setupIOManager(_holo[slide.id].getVirtual, _holo[slide.id].getShadow)\n\n    return slide.id\n  } catch (error) {\n    console.error('@Holo: Error creating carousel:', error)\n    return null\n  }\n}\n","//src/core/holo-performance.ts\n\nimport {cyre, CyreLog} from 'cyre'\nimport {_holo} from '../libs/holo-essentials'\nimport {EVENTS, PERFORMANCE} from '../config/holo-config'\n\n// Track performance metrics over time\nconst performanceHistory: Array<{\n  timestamp: number\n  stress: number\n  totalProcessingTime: number\n  frameRate?: number\n  carouselCount: number\n}> = []\n\n/**\n * Initialize performance monitoring system\n */\nexport const initializePerformanceMonitoring = (): void => {\n  CyreLog.info('Initializing performance monitoring')\n\n  registerPerformanceEvents()\n  startPerformanceMonitoring()\n}\n\n/**\n * Get current performance metrics\n */\nexport const getPerformanceMetrics = () => {\n  // Get Cyre's built-in metrics\n  const cyreMetrics = cyre.getPerformanceState()\n\n  return {\n    ...cyreMetrics,\n    history: performanceHistory.slice(-PERFORMANCE.STRESS_HISTORY_SIZE)\n  }\n}\n\n/**\n * Register performance-related events\n */\nfunction registerPerformanceEvents(): void {\n  // Global performance monitoring\n  cyre.on('global_performance_check', () => {\n    // Get current Cyre performance metrics\n    const metrics = cyre.getPerformanceState()\n\n    // Create a snapshot\n    const snapshot = {\n      timestamp: Date.now(),\n      stress: metrics.stress,\n      totalProcessingTime: metrics.totalProcessingTime,\n      // Estimate frame rate based on stress level (just a rough approximation)\n      frameRate:\n        metrics.stress > 0.5 ? 30 - Math.floor(metrics.stress * 20) : 60,\n      carouselCount: Object.keys(_holo).length\n    }\n\n    // Add to history\n    performanceHistory.push(snapshot)\n\n    // Trim history if needed\n    if (performanceHistory.length > PERFORMANCE.STRESS_HISTORY_SIZE * 2) {\n      performanceHistory.splice(\n        0,\n        performanceHistory.length - PERFORMANCE.STRESS_HISTORY_SIZE\n      )\n    }\n\n    // Check if any carousels need optimization\n    const carousels = Object.keys(_holo)\n\n    if (metrics.stress > PERFORMANCE.STRESS_THRESHOLD_HIGH) {\n      // Apply aggressive optimizations to all carousels\n      carousels.forEach(id => {\n        cyre.call(EVENTS.PERFORMANCE_OPTIMIZE, {\n          id,\n          stress: metrics.stress,\n          level: 'high'\n        })\n      })\n    } else if (metrics.stress > PERFORMANCE.STRESS_THRESHOLD_MEDIUM) {\n      // Apply moderate optimizations to all carousels\n      carousels.forEach(id => {\n        cyre.call(EVENTS.PERFORMANCE_OPTIMIZE, {\n          id,\n          stress: metrics.stress,\n          level: 'medium'\n        })\n      })\n    }\n  })\n\n  // Apply optimizations to a specific carousel\n  cyre.on(EVENTS.PERFORMANCE_OPTIMIZE, payload => {\n    const {id, level} = payload\n\n    if (!id || !_holo[id]) return\n\n    const virtual = _holo[id].getVirtual\n\n    // Apply optimizations based on level\n    switch (level) {\n      case 'high':\n        // Disable animations, increase throttling\n        _holo[id].setState = {\n          ...virtual,\n          io: {\n            ...virtual.io,\n            animate: 0,\n            wheel: 0,\n            duration: Math.max(400, virtual.io.duration || 0)\n          }\n        }\n        CyreLog.info(`Applied high-level optimizations to carousel ${id}`)\n        break\n      case 'medium':\n        // Slow down animations\n        _holo[id].setState = {\n          ...virtual,\n          io: {\n            ...virtual.io,\n            duration: Math.max(300, virtual.io.duration || 0)\n          }\n        }\n        CyreLog.info(`Applied medium-level optimizations to carousel ${id}`)\n        break\n    }\n  })\n\n  // Configure actions\n  cyre.action([\n    {\n      id: 'global_performance_check',\n      interval: 5000, // Check every 5 seconds\n      repeat: true, // Run continuously\n      log: false\n    },\n    {\n      id: EVENTS.PERFORMANCE_OPTIMIZE,\n      throttle: 1000 // Apply optimizations at most once per second\n    }\n  ])\n}\n\n/**\n * Start the performance monitoring system\n */\nfunction startPerformanceMonitoring(): void {\n  // Start monitoring\n  cyre.call('global_performance_check')\n}\n\n/**\n * Apply optimizations to a carousel based on its specific needs\n * Can be called directly\n */\nexport const optimizeCarousel = (\n  id: string,\n  level: 'light' | 'medium' | 'aggressive'\n): void => {\n  if (!id || !_holo[id]) {\n    CyreLog.warn(`Cannot optimize carousel ${id}: not found`)\n    return\n  }\n\n  const virtual = _holo[id].getVirtual\n\n  // Apply optimizations based on level\n  switch (level) {\n    case 'aggressive':\n      // Disable animations, input handling, increase throttling\n      _holo[id].setState = {\n        ...virtual,\n        io: {\n          ...virtual.io,\n          animate: 0,\n          wheel: 0,\n          drag: 0,\n          swipe: 0,\n          duration: Math.max(500, virtual.io.duration || 0)\n        }\n      }\n      CyreLog.info(`Applied aggressive optimizations to carousel ${id}`)\n      break\n    case 'medium':\n      // Disable animations, slower transitions\n      _holo[id].setState = {\n        ...virtual,\n        io: {\n          ...virtual.io,\n          animate: 0,\n          wheel: 0,\n          duration: Math.max(400, virtual.io.duration || 0)\n        }\n      }\n      CyreLog.info(`Applied medium optimizations to carousel ${id}`)\n      break\n    case 'light':\n      // Just slow down animations\n      _holo[id].setState = {\n        ...virtual,\n        io: {\n          ...virtual.io,\n          duration: Math.max(300, virtual.io.duration || 0)\n        }\n      }\n      CyreLog.info(`Applied light optimizations to carousel ${id}`)\n      break\n  }\n}\n\n/**\n * Get performance history\n */\nexport const getPerformanceHistory = () => {\n  return performanceHistory.slice(-PERFORMANCE.STRESS_HISTORY_SIZE)\n}\n","//src/utils/debug.ts\n\nimport {CyreLog} from 'cyre'\nimport {_holo} from '../libs/holo-essentials'\n\n/**\n * Debug mode flag\n */\nlet DEBUG_MODE = false\n\n/**\n * Enable or disable debug mode\n */\nexport const setDebugMode = (enabled: boolean): void => {\n  DEBUG_MODE = enabled\n  CyreLog.info(`Debug mode ${enabled ? 'enabled' : 'disabled'}`)\n}\n\n/**\n * Toggle debug mode\n */\nexport const toggleDebugMode = (): boolean => {\n  DEBUG_MODE = !DEBUG_MODE\n  CyreLog.info(`Debug mode ${DEBUG_MODE ? 'enabled' : 'disabled'}`)\n  return DEBUG_MODE\n}\n\n/**\n * Log only in debug mode\n */\nexport const debugLog = (message: string, ...args: any[]): void => {\n  if (DEBUG_MODE) {\n    CyreLog.debug(message, ...args)\n  }\n}\n\n/**\n * Add visual debug overlays to carousels\n */\nexport const addDebugOverlays = (): void => {\n  if (!DEBUG_MODE) return\n\n  Object.keys(_holo).forEach(id => {\n    const carousel = document.getElementById(id)\n    if (!carousel) return\n\n    // Add debug class\n    carousel.classList.add('holo-debug')\n\n    // Create debug overlay if not exists\n    let debugOverlay = carousel.querySelector('.holo-debug-overlay')\n    if (!debugOverlay) {\n      debugOverlay = document.createElement('div')\n      debugOverlay.className = 'holo-debug-overlay'\n      carousel.appendChild(debugOverlay)\n    }\n\n    // Update debug info\n    const virtual = _holo[id].getVirtual\n    ;(debugOverlay as HTMLElement).innerHTML = `\n      <div class=\"holo-debug-info\">\n        <div>ID: ${id}</div>\n        <div>X: ${Math.round(virtual.transformX)}</div>\n        <div>Y: ${Math.round(virtual.transformY)}</div>\n        <div>End of Slide: ${virtual.endOfSlide}</div>\n        <div>Orientation: ${\n          virtual.io.orientation ? 'Vertical' : 'Horizontal'\n        }</div>\n      </div>\n    `\n  })\n}\n\n/**\n * Remove debug overlays\n */\nexport const removeDebugOverlays = (): void => {\n  document.querySelectorAll('.holo-debug-overlay').forEach(overlay => {\n    overlay.remove()\n  })\n  document.querySelectorAll('.holo-debug').forEach(element => {\n    element.classList.remove('holo-debug')\n  })\n}\n\n/**\n * Add debug CSS to the document\n */\nexport const injectDebugStyles = (): void => {\n  if (!DEBUG_MODE) return\n\n  const styleId = 'holo-debug-styles'\n  if (document.getElementById(styleId)) return\n\n  const style = document.createElement('style')\n  style.id = styleId\n  style.textContent = `\n    .holo-debug {\n      position: relative;\n    }\n    \n    .holo-debug-overlay {\n      position: absolute;\n      top: 0;\n      left: 0;\n      background: rgba(0, 0, 0, 0.7);\n      color: #fff;\n      padding: 5px;\n      border-radius: 3px;\n      font-size: 10px;\n      z-index: 9999;\n      pointer-events: none;\n    }\n    \n    .holo-debug .holo-container {\n      outline: 1px solid rgba(255, 0, 0, 0.5);\n    }\n    \n    .holo-debug .holo {\n      outline: 1px dashed rgba(0, 255, 0, 0.5);\n    }\n  `\n  document.head.appendChild(style)\n}\n\n/**\n * Monitor carousel performance and state changes\n */\nexport const enableStateMonitoring = (): (() => void) => {\n  if (!DEBUG_MODE) return () => {}\n\n  const intervalId = setInterval(() => {\n    addDebugOverlays()\n  }, 500)\n\n  return () => clearInterval(intervalId)\n}\n\n/**\n * Initialize debugging tools\n */\nexport const initializeDebugTools = (enabled: boolean = false): void => {\n  setDebugMode(enabled)\n\n  if (enabled) {\n    injectDebugStyles()\n    const stopMonitoring = enableStateMonitoring()\n\n    // Add to window for console access\n    ;(window as any).holoDebug = {\n      toggleDebugMode,\n      addDebugOverlays,\n      removeDebugOverlays,\n      getDatabaseState: () => ({..._holo}),\n      stopMonitoring\n    }\n  }\n}\n","//src/app.ts\n\n/* \n    Neural Line\n    Reactive Carousel\n    H.O.L.O - C.A.R.O.U.S.E.L\n    Version 3.5.0 (2025)\n*/\n\nimport {cyre, CyreLog} from 'cyre'\nimport type {HoloIOOptions, HoloVirtual} from './types/interface'\nimport {holoCreateElement} from './components/holo-create-element'\nimport {_holo} from './libs/holo-essentials'\nimport {holoInitiate} from './components/holo-initiate'\nimport {EVENTS, DEFAULT_IO_OPTIONS, CSS_CLASSES} from './config/holo-config'\nimport {\n  safeEventCall,\n  createEventIds,\n  initializeEventSystem,\n  initializeInstanceEvents\n} from './core/holo-events'\nimport {handleTouchStart, initializeTouchSystem} from './components/holo-touch'\nimport {\n  getCurrentSlideIndex,\n  updateActiveSlide,\n  forceRefreshAllCarousels,\n  calculateCarouselDimensions\n} from './libs/holo-dom'\nimport {\n  initializePerformanceMonitoring,\n  getPerformanceHistory,\n  optimizeCarousel\n} from './core/holo-performance'\nimport {\n  goToNextSlide,\n  goToPrevSlide,\n  goToFirstSlide,\n  goToLastSlide,\n  goToSlide\n} from './libs/holo-navigation'\nimport {initializeDebugTools} from './libs/debug'\n\n// Update the updateCarouselOptions function in app.ts\n\nfunction updateCarouselOptions(\n  id: string,\n  options: Partial<HoloIOOptions> = {}\n): {ok: boolean; data: HoloIOOptions | string} {\n  try {\n    if (!_holo[id]) {\n      return {ok: false, data: `Carousel with ID ${id} not found`}\n    }\n\n    const virtual = _holo[id].getVirtual\n\n    // Filter valid options\n    const validOptions = Object.entries(options).reduce((acc, [key, value]) => {\n      if (key in DEFAULT_IO_OPTIONS) {\n        return {...acc, [key]: value}\n      }\n      CyreLog.warn(`Invalid option ignored: ${key}`)\n      return acc\n    }, {})\n\n    // CRITICAL FIX: Special handling for animation\n    if ('animate' in validOptions) {\n      // Clean up any existing animation event\n      if (virtual.eventIds?.animate) {\n        cyre.forget(virtual.eventIds.animate)\n        CyreLog.info(`Removed existing animation for carousel ${id}`)\n      }\n    }\n\n    // Create updated options\n    const updatedIO = {\n      ...virtual.io,\n      ...validOptions\n    }\n\n    // Update state\n    _holo[id].setState = {\n      ..._holo[id].getVirtual,\n      io: updatedIO\n    }\n\n    // Re-initialize instance events with new options\n    // This will properly set up the animation if enabled\n    initializeInstanceEvents(id, updatedIO)\n\n    CyreLog.info(`Carousel ${id} options updated successfully`)\n\n    return {ok: true, data: updatedIO}\n  } catch (error) {\n    CyreLog.error('Error updating carousel options:', error)\n    return {\n      ok: false,\n      data: error instanceof Error ? error.message : 'Unknown error'\n    }\n  }\n}\n\n/**\n * Get carousel dimensions and state\n */\nfunction getCarouselDimensions(id: string) {\n  if (!_holo[id]) {\n    CyreLog.warn(`Carousel with ID ${id} not found`)\n    return null\n  }\n  return _holo[id].getDimensions\n}\n\n/**\n * Get carousel state\n */\nfunction getCarouselState(id: string): HoloVirtual | null {\n  if (!_holo[id]) {\n    CyreLog.warn(`Carousel with ID ${id} not found`)\n    return null\n  }\n  return _holo[id].getVirtual\n}\n\n/**\n * Refresh all carousels with more robust error handling\n */\nfunction refreshAllCarousels(): void {\n  try {\n    const carouselIds = Object.keys(_holo)\n    if (carouselIds.length === 0) {\n      CyreLog.info('No carousels to refresh')\n      return\n    }\n\n    CyreLog.info(`Refreshing ${carouselIds.length} carousels`)\n\n    // First trigger a global refresh\n    cyre.call(EVENTS.REFRESH_SCREEN)\n\n    // Then refresh each carousel individually to ensure all are updated\n    carouselIds.forEach(id => {\n      try {\n        if (!_holo[id]?.getShadow?.carousel) {\n          CyreLog.warn(\n            `Missing DOM elements for carousel ${id}, skipping refresh`\n          )\n          return\n        }\n\n        // Ensure the carousel element is visible in the DOM\n        const isVisible =\n          _holo[id].getShadow.carousel.offsetWidth > 0 ||\n          _holo[id].getShadow.carousel.offsetHeight > 0\n\n        if (!isVisible) {\n          CyreLog.warn(`Carousel ${id} not visible in DOM, skipping refresh`)\n          return\n        }\n\n        // Call refresh with current state\n        cyre.call(EVENTS.REFRESH_CAROUSEL, _holo[id].getState)\n      } catch (innerError) {\n        CyreLog.error(`Error refreshing carousel ${id}:`, innerError)\n      }\n    })\n  } catch (error) {\n    CyreLog.error('Error in global refresh:', error)\n  }\n}\n\n/**\n * Setup window resize handler\n */\nfunction setupWindowResizeHandler(): void {\n  // Configure resize event with throttling\n  cyre.action({\n    id: 'window-resize',\n    throttle: 200,\n    log: false\n  })\n\n  // Register resize handler\n  cyre.on('window-resize', () => {\n    return {\n      id: EVENTS.REFRESH_SCREEN,\n      payload: null\n    }\n  })\n\n  // Add event listener\n  window.addEventListener(\n    'resize',\n    () => {\n      cyre.call('window-resize')\n    },\n    {passive: true}\n  )\n}\n\n/**\n * Initialize the Holo carousel system\n * Prepares the global event system\n */\nfunction initialize(selector: string = CSS_CLASSES.CAROUSEL): string {\n  CyreLog.info(`Initializing Holo with selector: ${selector}`)\n\n  // Schedule a refresh when everything is loaded\n  window.addEventListener('load', () => {\n    // First fast refresh\n    refreshAllCarousels()\n\n    // Then a more thorough refresh with delay to ensure dimensions are calculated\n    setTimeout(() => {\n      forceRefreshAllCarousels().then(() => {\n        CyreLog.info('Force refresh completed successfully')\n      })\n    }, 300)\n  })\n\n  // Return the selector for chaining\n  return selector\n}\n\n/**\n * Navigate to next slide\n */\nfunction nextSlide(id: string): void {\n  if (!_holo[id]) {\n    CyreLog.warn(`Carousel with ID ${id} not found`)\n    return\n  }\n\n  // Use the navigation function from our shared library\n  goToNextSlide(_holo[id].getVirtual)\n}\n\n/**\n * Navigate to previous slide\n */\nfunction prevSlide(id: string): void {\n  if (!_holo[id]) {\n    CyreLog.warn(`Carousel with ID ${id} not found`)\n    return\n  }\n\n  // Use the navigation function from our shared library\n  goToPrevSlide(_holo[id].getVirtual)\n}\n\n/**\n * Go to first slide\n */\nfunction firstSlide(id: string): void {\n  if (!_holo[id]) {\n    CyreLog.warn(`Carousel with ID ${id} not found`)\n    return\n  }\n\n  // Use the navigation function from our shared library\n  goToFirstSlide(_holo[id].getVirtual)\n}\n\n/**\n * Go to last slide\n */\nfunction lastSlide(id: string): void {\n  if (!_holo[id]) {\n    CyreLog.warn(`Carousel with ID ${id} not found`)\n    return\n  }\n\n  // Use the navigation function from our shared library\n  goToLastSlide(_holo[id].getVirtual)\n}\n\n/**\n * Go to specific slide index\n */\nfunction goToSlideById(id: string, index: number): void {\n  if (!_holo[id]) {\n    CyreLog.warn(`Carousel with ID ${id} not found`)\n    return\n  }\n\n  // Use the navigation function from our shared library\n  goToSlide(_holo[id].getVirtual, index)\n}\n\n/**\n * Get current position index\n */\nfunction getCurrentPosition(id: string): number {\n  if (!_holo[id]) return 0\n\n  // Use the slide index calculation from our shared library\n  return getCurrentSlideIndex(_holo[id].getVirtual)\n}\n\n/**\n * Apply performance optimizations to a carousel\n */\nfunction optimizeCarouselPerformance(\n  id: string,\n  level: 'light' | 'medium' | 'aggressive'\n): void {\n  optimizeCarousel(id, level)\n}\n\n// Initialize the event system immediately\nCyreLog.info(\n  '%c HOLO - Initializing Holo Carousel v3.5.0 ',\n  'background: #022d5f; color: white; display: block;'\n)\n\n// Enable debug tools (can be toggled via query param ?debug=true)\nconst urlParams =\n  typeof window !== 'undefined'\n    ? new URLSearchParams(window.location.search)\n    : null\nconst debugEnabled = urlParams?.has('debug') || false\ninitializeDebugTools(debugEnabled)\n\n// Initialize core systems\ninitializeEventSystem()\n\n// Initialize the touch system\ninitializeTouchSystem()\n\n// Initialize performance monitoring\ninitializePerformanceMonitoring()\n\n// Register window resize handler\nsetupWindowResizeHandler()\n\n// Create and export the Holo API\nconst Holo = {\n  // Core initialization\n  INIT: initialize,\n  AUTO: holoInitiate,\n  BUILD: holoCreateElement,\n\n  // Configuration and state access\n  carousel: updateCarouselOptions,\n  dimensions: getCarouselDimensions,\n  getState: getCarouselState,\n  getPosition: getCurrentPosition,\n\n  // Navigation\n  next: nextSlide,\n  prev: prevSlide,\n  first: firstSlide,\n  last: lastSlide,\n  goTo: goToSlideById,\n\n  // System operations\n  refresh: refreshAllCarousels,\n  getPerformanceHistory,\n  optimize: optimizeCarouselPerformance,\n\n  // Touch handling\n  handleTouchStart,\n\n  // Constants\n  EVENTS\n}\n\n// Export for module use\nexport default Holo\n\n// Also expose to window for UMD/browser usage\nif (typeof window !== 'undefined') {\n  ;(window as any).Holo = Holo\n}\n","//src/components/holo-initiate.ts\n\nimport {CyreLog} from 'cyre'\nimport type {HoloIOOptions} from '../types/interface'\nimport {holoCreateElement} from './holo-create-element'\n\n/**\n * Auto-initialize all carousels with the specified class name\n * @param carouselName - Class name to identify carousels\n */\nexport const holoInitiate = (carouselName: string = 'holo-carousel'): void => {\n  console.log('@holo holo auto activated:', carouselName)\n\n  // Get all elements with the specified class name\n  const carousels = document.getElementsByClassName(carouselName)\n\n  if (carousels.length === 0) {\n    console.log('@Holo: carousel structure not found')\n    return\n  }\n\n  // Initialize each carousel\n  Array.from(carousels).forEach(carousel => {\n    try {\n      const element = carousel as HTMLElement\n      holoCreateElement(element, {} as Partial<HoloIOOptions>)\n    } catch (error) {\n      CyreLog.error('Error auto-initializing carousel:', error)\n    }\n  })\n}\n"],"names":["e","t","reset","magenta","magentaBright","red","redBright","green","greenBright","cyan","cyanBright","yellow","yellowBright","white","whiteBright","blue","blueBright","bgRed","bgYellow","bgBlue","bold","dim","italic","underline","r","DEBUG","INFO","WARN","ERROR","SUCCESS","o","process","versions","node","i","window","a","n","s","c","u","l","Date","toISOString","Error","message","stack","JSON","stringify","String","console","reduce","stdout","write","error","warn","info","debug","success","WeakMap","has","set","get","Object","is","Array","isArray","length","every","keys","d","RECUPERATION","MAX_TIMEOUT","Math","pow","m","p","g","f","y","h","b","v","E","k","I","T","w","R","A","M","$","C","x","O","S","D","N","q","MIN","BASE","MAX","RECOVERY","U","HIGH","CRITICAL","B","MAX_CPU","MAX_MEMORY","MAX_EVENT_LOOP","MAX_CALL_RATE","_","system","cpu","memory","eventLoop","isOverloaded","breathing","breathCount","currentRate","lastBreath","now","stress","isRecuperating","recuperationDepth","pattern","nextBreathDue","performance","callsTotal","callsPerSecond","lastCallTimestamp","activeQueues","critical","high","medium","low","background","queueDepth","callRate","combined","lastUpdate","inRecuperation","hibernating","activeFormations","F","Map","size","from","slice","forEach","delete","forget","clear","getAll","values","L","P","min","max","X","exp","j","recuperationInterval","freeze","update","updateBreath","recordCall","e2","isHealthy","shouldAllowCall","H","V","G","z","W","Y","intervalId","clearInterval","Q","id","timestamp","type","lastExecutionTime","executionCount","errors","detectChanges","payload","priority","level","J","K","Z","ee","te","re","oe","fn","ie","ae","ne","se","ce","timeoutId","clearTimeout","ue","le","de","filter","status","me","ok","done","pe","skipped","skipReason","ge","intraLink","fe","log","ye","isValid","he","entries","required","map","push","join","interval","timeOfCreation","be","code","subscriber","trim","ve","Boolean","Ee","async","isActive","callback","metrics","totalExecutions","successfulExecutions","longestExecutionTime","shortestExecutionTime","averageExecutionTime","repeat","Ie","failedExecutions","ke","duration","abs","originalDuration","nextExecutionTime","setTimeout","isInRecuperation","env","NODE_ENV","hrtime","setImmediate","floor","Te","crypto","randomUUID","startTime","missedExecutions","days","hours","minutes","seconds","milliseconds","kind","value","we","Re","Ae","Me","Number","isInteger","group","middleware","throttle","debounce","at","$e","round","toFixed","executionTime","exit","addEventListener","on","initialize","call","action","shutdown","pause","resume","hasChanged","getPreviousPayload","getBreathingState","getPerformanceState","totalProcessingTime","totalCallTime","totalStress","getMetrics","formations","breathingSync","Ce","Cyre","CyreLog","cyre","cancel","default","isEqual","memoize","pipe","tryCatch","version","defineProperties","__esModule","Symbol","toStringTag","TOUCH_EVENTS","EVENTS","INIT_CAROUSEL","INIT_DIMENSIONS","STATE_UPDATE","STATE_BATCH_UPDATE","REFRESH_CAROUSEL","REFRESH_SCREEN","SNAP_TO_POSITION","SNAP","TRANSFORM_COMPLETE","ANIMATE_FORWARD","ANIMATE_BACKWARD","NEXT_SLIDE","PREV_SLIDE","FIRST_SLIDE","LAST_SLIDE","GO_TO_SLIDE","ACTIVATE","BRING_TO_FOCUS","WHEEL_EVENT","KEYBOARD_EVENT","SHAKE","ERROR_HANDLER","PERFORMANCE_MONITOR","PERFORMANCE_OPTIMIZE","ANIMATION","PERFORMANCE","DEFAULT_IO_OPTIONS","enabled","wheel","controller","drag","swipe","snap","focus","animate","animateDirection","loop","orientation","active","onClick","onDoubleClick","CSS_CLASSES","calculateCarouselDimensions","virtual","shadow","container","carousel","cyreExports","offsetWidth","offsetHeight","originalCarouselStyle","style","cssText","originalContainerStyle","visibility","display","slides","children","parentWidth","parentElement","clientWidth","innerWidth","parentHeight","clientHeight","innerHeight","flexGap","getComputedStyle","gap","gapValue","parseInt","isNaN","gapVar","document","documentElement","getPropertyValue","rowGap","columnGap","getFlexGap","totalWidth","totalHeight","maxSlideWidth","maxSlideHeight","slide","index","originalSlideStyle","marginLeft","marginRight","marginTop","marginBottom","slideWidth","slideHeight","numberOfSlots","item","carouselWidth","io","carouselHeight","containerWidth","containerHeight","endOfSlidePosition","slideWithGap","width","height","actualWidth","actualHeight","slideWithGapWidth","slideWithGapHeight","noOfChildren","forceCalculateCarouselDimensions","Promise","resolve","_holo","state","getState","updatedVirtual","setDimension","retryVirtual","getCurrentSlideIndex","slideDimension","position","transformY","transformX","applyTransform","light","calculatedEndPosition","endOfSlide","transformYLite","snapToGrid","transformXLite","goToNextSlide","currentPosition","currentIndex","maxIndex","nextIndex","newTransform","minPosition","newPosition","goToPrevSlide","prevIndex","goToFirstSlide","goToLastSlide","lastSlidePosition","absoluteEndPosition","finalPosition","goToSlide","safeIndex","activateSlide","element","offsets","selectedIndex","selectedElement","querySelector","findIndex","getSlideOffsets","querySelectorAll","el","classList","remove","add","animateCarousel","directionForward","createEventIds","prevSlide","nextSlide","lastSlide","firstSlide","activate","refresh","transform","stateUpdate","dimensionUpdate","initializeInstanceEvents","options","getVirtual","eventIds","setState","eventId","gridSize","touchState","startX","startY","currentX","currentY","lastX","lastY","distanceX","distanceY","directionX","directionY","velocityX","velocityY","startTransformX","startTransformY","pressed","multiplier","targetElement","moved","handleTouchStart","event","preventDefault","calculateSwipeSpeed","distance","timeElapsed","isClickEvent","setupDomEventHandlers","handleMouseDown","stopPropagation","passive","touchStartHandler","wheelHandler","deltaY","handleWheel","prevButton","nextButton","handleResize","createDefaultIOOptions","createHoloInstance","getElementsByClassName","title","description","transitionTiming","transformZ","startNumber","createDefaultVirtual","childrenCount","initializedVirtual","stateUpdatedId","this","getShadow","getDimensions","car","con","updateDOMTransform","updateDOMDimensions","updateStyle","updateTransitionStyle","enableTransition","transitionDuration","transitionTimingFunction","holoCreateElement","nodeType","setupIOManager","performanceHistory","DEBUG_MODE","toggleDebugMode","addDebugOverlays","getElementById","debugOverlay","createElement","className","appendChild","innerHTML","removeDebugOverlays","overlay","refreshAllCarousels","carouselIds","innerError","urlParams","URLSearchParams","location","search","setDebugMode","styleId","textContent","head","injectDebugStyles","stopMonitoring","setInterval","enableStateMonitoring","holoDebug","getDatabaseState","initializeDebugTools","source","data","changes","property","includes","visibilityState","virtualId","setAttribute","transformedVirtual","safeX","safeY","clientX","touches","clientY","target","newTransformX","newTransformY","elapsed","touchData","carouselId","velocity","absVelocity","direction","closestItem","closest","constrainedVirtual","handlePointerMove","handlePointerEnd","registerDomEventListeners","initializeTouchSystem","snapshot","frameRate","carouselCount","splice","carousels","Holo","INIT","selector","forceRefreshAllCarousels","then","AUTO","carouselName","BUILD","validOptions","acc","key","updatedIO","dimensions","getPosition","next","prev","first","last","goTo","getPerformanceHistory","optimize","optimizeCarousel"],"mappings":"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","x_google_ignoreList":[0]}